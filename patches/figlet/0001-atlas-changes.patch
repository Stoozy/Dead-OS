From e8830db37922e26ba1a548a869eefcaf2053c53e Mon Sep 17 00:00:00 2001
From: stoozy <stoozy@proton.me>
Date: Sun, 19 Feb 2023 18:01:47 -0500
Subject: [PATCH] atlas changes

---
 figlet.c | 2117 +++++++++++++++++++++++++++---------------------------
 1 file changed, 1070 insertions(+), 1047 deletions(-)

diff --git a/figlet.c b/figlet.c
index 6daaf4c..1e1a04e 100644
--- a/figlet.c
+++ b/figlet.c
@@ -28,12 +28,12 @@
 /* Control files by Glenn Chappell Feb 1994 */
 /* Release 2.1 12 Aug 1994 */
 /* Release 2.1.1 25 Aug 1994 */
-/* Release 2.1.2 by Gilbert (Mad Programmer) Healton: Add -A command line 
+/* Release 2.1.2 by Gilbert (Mad Programmer) Healton: Add -A command line
    option.  Sept 8, 1996 */
 /* Release 2.2 by John Cowan: multibyte inputs, compressed fonts,
    mapping tables, kerning/smushing options. */
 /* Release 2.2.1 by Christiaan Keet: minor updates including readmes
-   FAQs and comments. 13 July 2002. The new official FIGlet website is 
+   FAQs and comments. 13 July 2002. The new official FIGlet website is
    http://www.figlet.org/  */
 /* Release 2.2.2 by Christiaan Keet: License changed from "Artistic License"
    to "Academic Free License" as agreed by FIGlet authors. 05 July 2005 */
@@ -61,23 +61,24 @@
 #ifdef __STDC__
 #include <stdlib.h>
 #endif
-#include <string.h>
 #include <ctype.h>
+#include <fcntl.h> /* Needed for get_columns */
+#include <string.h>
 #include <sys/stat.h>
-#include <fcntl.h>     /* Needed for get_columns */
 
 #if defined(unix) || defined(__unix__) || defined(__APPLE__)
-#include <unistd.h>
 #include <sys/ioctl.h> /* Needed for get_columns */
+#include <unistd.h>
 #endif
 
 #ifdef TLF_FONTS
+#include "utf8.h"
 #include <wchar.h>
 #include <wctype.h>
-#include "utf8.h"
 #endif
 
-#include "zipio.h"     /* Package for reading compressed files */
+#include "zipio.h" /* Package for reading compressed files */
+#include <termios.h>
 
 #define MYSTRLEN(x) ((int)strlen(x)) /* Eliminate ANSI problem */
 
@@ -90,10 +91,10 @@ Note: '/' also used in filename in get_columns(). */
 #define FONTFILEMAGICNUMBER "flf2"
 #define FSUFFIXLEN MYSTRLEN(FONTFILESUFFIX)
 #define CONTROLFILESUFFIX ".flc"
-#define CONTROLFILEMAGICNUMBER "flc2"   /* no longer used in 2.2 */
+#define CONTROLFILEMAGICNUMBER "flc2" /* no longer used in 2.2 */
 #define CSUFFIXLEN MYSTRLEN(CONTROLFILESUFFIX)
 #define DEFAULTCOLUMNS 80
-#define MAXLEN 255     /* Maximum character width */
+#define MAXLEN 255 /* Maximum character width */
 
 /* Add support for Sam Hocevar's TOIlet fonts */
 #ifdef TLF_FONTS
@@ -101,10 +102,9 @@ Note: '/' also used in filename in get_columns(). */
 #define TOILETFILEMAGICNUMBER "tlf2"
 #define TSUFFIXLEN MYSTRLEN(TOILETFILESUFFIX)
 
-int toiletfont;	/* true if font is a TOIlet TLF font */
+int toiletfont; /* true if font is a TOIlet TLF font */
 #endif
 
-
 /****************************************************************************
 
   Globals dealing with chars that are read
@@ -113,27 +113,27 @@ int toiletfont;	/* true if font is a TOIlet TLF font */
 
 typedef long inchr; /* "char" read from stdin */
 
-inchr *inchrline;  /* Alloc'd inchr inchrline[inchrlinelenlimit+1]; */
-                   /* Note: not null-terminated. */
-int inchrlinelen,inchrlinelenlimit;
+inchr *inchrline; /* Alloc'd inchr inchrline[inchrlinelenlimit+1]; */
+                  /* Note: not null-terminated. */
+int inchrlinelen, inchrlinelenlimit;
 inchr deutsch[7] = {196, 214, 220, 228, 246, 252, 223};
-  /* Latin-1 codes for German letters, respectively:
-     LATIN CAPITAL LETTER A WITH DIAERESIS = A-umlaut
-     LATIN CAPITAL LETTER O WITH DIAERESIS = O-umlaut
-     LATIN CAPITAL LETTER U WITH DIAERESIS = U-umlaut
-     LATIN SMALL LETTER A WITH DIAERESIS = a-umlaut
-     LATIN SMALL LETTER O WITH DIAERESIS = o-umlaut
-     LATIN SMALL LETTER U WITH DIAERESIS = u-umlaut
-     LATIN SMALL LETTER SHARP S = ess-zed
-  */
-
-int hzmode;  /* true if reading double-bytes in HZ mode */
+/* Latin-1 codes for German letters, respectively:
+   LATIN CAPITAL LETTER A WITH DIAERESIS = A-umlaut
+   LATIN CAPITAL LETTER O WITH DIAERESIS = O-umlaut
+   LATIN CAPITAL LETTER U WITH DIAERESIS = U-umlaut
+   LATIN SMALL LETTER A WITH DIAERESIS = a-umlaut
+   LATIN SMALL LETTER O WITH DIAERESIS = o-umlaut
+   LATIN SMALL LETTER U WITH DIAERESIS = u-umlaut
+   LATIN SMALL LETTER SHARP S = ess-zed
+*/
+
+int hzmode;   /* true if reading double-bytes in HZ mode */
 int gndbl[4]; /* gndbl[n] is true if Gn is double-byte */
-inchr gn[4]; /* Gn character sets: ASCII, Latin-1, none, none */
-int gl; /* 0-3 specifies left-half Gn character set */
-int gr; /* 0-3 specifies right-half Gn character set */
+inchr gn[4];  /* Gn character sets: ASCII, Latin-1, none, none */
+int gl;       /* 0-3 specifies left-half Gn character set */
+int gr;       /* 0-3 specifies right-half Gn character set */
 
-int Myargc;  /* to avoid passing around argc and argv */
+int Myargc; /* to avoid passing around argc and argv */
 char **Myargv;
 
 /****************************************************************************
@@ -145,31 +145,31 @@ char **Myargv;
 #ifdef TLF_FONTS
 typedef wchar_t outchr; /* "char" written to stdout */
 #define STRLEN(x) wcslen(x)
-#define STRCPY(x,y) wcscpy((x),(y))
-#define STRCAT(x,y) wcscat((x),(y))
+#define STRCPY(x, y) wcscpy((x), (y))
+#define STRCAT(x, y) wcscat((x), (y))
 #define ISSPACE(x) iswspace(x)
 #else
 typedef char outchr; /* "char" written to stdout */
 #define STRLEN(x) MYSTRLEN(x)
-#define STRCPY(x,y) strcpy((x),(y))
-#define STRCAT(x,y) strcat((x),(y))
+#define STRCPY(x, y) strcpy((x), (y))
+#define STRCAT(x, y) strcat((x), (y))
 #define ISSPACE(x) isspace(x)
 #endif
 
 typedef struct fc {
   inchr ord;
-  outchr **thechar;  /* Alloc'd char thechar[charheight][]; */
+  outchr **thechar; /* Alloc'd char thechar[charheight][]; */
   struct fc *next;
-  } fcharnode;
+} fcharnode;
 
 fcharnode *fcharlist;
 outchr **currchar;
 int currcharwidth;
 int previouscharwidth;
-outchr **outputline;   /* Alloc'd char outputline[charheight][outlinelenlimit+1]; */
+outchr *
+    *outputline; /* Alloc'd char outputline[charheight][outlinelenlimit+1]; */
 int outlinelen;
 
-
 /****************************************************************************
 
   Globals dealing with command file storage
@@ -179,9 +179,9 @@ int outlinelen;
 typedef struct cfn {
   char *thename;
   struct cfn *next;
-  } cfnamenode;
+} cfnamenode;
 
-cfnamenode *cfilelist,**cfilelistend;
+cfnamenode *cfilelist, **cfilelistend;
 
 typedef struct cm {
   int thecommand;
@@ -189,9 +189,9 @@ typedef struct cm {
   inchr rangehi;
   inchr offset;
   struct cm *next;
-  } comnode;
+} comnode;
 
-comnode *commandlist,**commandlistend;
+comnode *commandlist, **commandlistend;
 
 /****************************************************************************
 
@@ -199,7 +199,7 @@ comnode *commandlist,**commandlistend;
 
 ****************************************************************************/
 
-int deutschflag,justification,paragraphflag,right2left,multibyte;
+int deutschflag, justification, paragraphflag, right2left, multibyte;
 int cmdinput;
 
 #define SM_SMUSH 128
@@ -213,16 +213,15 @@ int cmdinput;
 
 int smushmode;
 
-#define SMO_NO 0     /* no command-line smushmode */
-#define SMO_YES 1    /* use command-line smushmode, ignore font smushmode */
-#define SMO_FORCE 2  /* logically OR command-line and font smushmodes */
+#define SMO_NO 0    /* no command-line smushmode */
+#define SMO_YES 1   /* use command-line smushmode, ignore font smushmode */
+#define SMO_FORCE 2 /* logically OR command-line and font smushmodes */
 
 int smushoverride;
 
 int outputwidth;
 int outlinelenlimit;
-char *fontdirname,*fontname;
-
+char *fontdirname, *fontname;
 
 /****************************************************************************
 
@@ -233,7 +232,6 @@ char *fontdirname,*fontname;
 char hardblank;
 int charheight;
 
-
 /****************************************************************************
 
   Name of program, used in error messages
@@ -242,7 +240,6 @@ int charheight;
 
 char *myname;
 
-
 #ifdef TIOCGWINSZ
 /****************************************************************************
 
@@ -255,19 +252,18 @@ char *myname;
 
 ****************************************************************************/
 
-int get_columns()
-{
+int get_columns() {
   struct winsize ws;
-  int fd,result;
+  int fd, result;
 
-  if ((fd = open("/dev/tty",O_WRONLY))<0) return -1;
-  result = ioctl(fd,TIOCGWINSZ,&ws);
+  if ((fd = open("/dev/tty", O_WRONLY)) < 0)
+    return -1;
+  result = ioctl(fd, TIOCGWINSZ, &ws);
   close(fd);
-  return result?-1:ws.ws_col;
+  return result ? -1 : ws.ws_col;
 }
 #endif /* ifdef TIOCGWINSZ */
 
-
 /****************************************************************************
 
   myalloc
@@ -289,16 +285,14 @@ int size;
   extern void *malloc();
 #endif
 
-  if ((ptr = (char*)malloc(size))==NULL) {
-    fprintf(stderr,"%s: Out of memory\n",myname);
+  if ((ptr = (char *)malloc(size)) == NULL) {
+    fprintf(stderr, "%s: Out of memory\n", myname);
     exit(1);
-    }
-  else {
+  } else {
     return ptr;
-    }
+  }
 }
 
-
 /****************************************************************************
 
   hasdirsep
@@ -310,9 +304,12 @@ int size;
 int hasdirsep(s1)
 char *s1;
 {
-  if (strchr(s1, DIRSEP)) return 1;
-  else if (strchr(s1, DIRSEP2)) return 1;
-  else return 0;
+  if (strchr(s1, DIRSEP))
+    return 1;
+  else if (strchr(s1, DIRSEP2))
+    return 1;
+  else
+    return 0;
 }
 
 /****************************************************************************
@@ -331,16 +328,18 @@ char *s2;
 
   len1 = MYSTRLEN(s1);
   len2 = MYSTRLEN(s2);
-  if (len2 > len1) return 0;
+  if (len2 > len1)
+    return 0;
   s1 += len1 - len2;
   while (*s1) {
-    if (tolower(*s1) != tolower(*s2)) return 0;
+    if (tolower(*s1) != tolower(*s2))
+      return 0;
     s1++;
     s2++;
-    }
+  }
   return 1;
 }
-   
+
 /****************************************************************************
 
   skiptoeol
@@ -349,22 +348,22 @@ char *s2;
 
 ****************************************************************************/
 
-void skiptoeol(fp)
-ZFILE *fp;
+void skiptoeol(fp) ZFILE *fp;
 {
   int dummy;
 
-  while (dummy=Zgetc(fp),dummy!=EOF) {
-    if (dummy == '\n') return;
+  while (dummy = Zgetc(fp), dummy != EOF) {
+    if (dummy == '\n')
+      return;
     if (dummy == '\r') {
       dummy = Zgetc(fp);
-      if (dummy != EOF && dummy != '\n') Zungetc(dummy,fp);
+      if (dummy != EOF && dummy != '\n')
+        Zungetc(dummy, fp);
       return;
-      }
+    }
   }
 }
 
-
 /****************************************************************************
 
   myfgets
@@ -373,7 +372,7 @@ ZFILE *fp;
 
 ****************************************************************************/
 
-char *myfgets(line,maxlen,fp)
+char *myfgets(line, maxlen, fp)
 char *line;
 int maxlen;
 ZFILE *fp;
@@ -382,22 +381,23 @@ ZFILE *fp;
   char *p;
 
   p = line;
-  while((c=Zgetc(fp))!=EOF&&maxlen) {
+  while ((c = Zgetc(fp)) != EOF && maxlen) {
     *p++ = c;
     maxlen--;
-    if (c=='\n') break;
-    if (c=='\r') {
+    if (c == '\n')
+      break;
+    if (c == '\r') {
       c = Zgetc(fp);
-      if (c != EOF && c != '\n') Zungetc(c,fp);
-      *(p-1) = '\n';
+      if (c != EOF && c != '\n')
+        Zungetc(c, fp);
+      *(p - 1) = '\n';
       break;
-      }
     }
+  }
   *p = 0;
-  return (c==EOF) ? NULL : line;
+  return (c == EOF) ? NULL : line;
 }
 
-
 /****************************************************************************
 
   usageerr
@@ -406,19 +406,17 @@ ZFILE *fp;
 
 ****************************************************************************/
 
-void printusage(out)
-FILE *out;
+void printusage(out) FILE *out;
 {
+  fprintf(out, "Usage: %s [ -cklnoprstvxDELNRSWX ] [ -d fontdirectory ]\n",
+          myname);
+  fprintf(
+      out,
+      "              [ -f fontfile ] [ -m smushmode ] [ -w outputwidth ]\n");
   fprintf(out,
-    "Usage: %s [ -cklnoprstvxDELNRSWX ] [ -d fontdirectory ]\n",
-    myname);
-  fprintf(out,
-    "              [ -f fontfile ] [ -m smushmode ] [ -w outputwidth ]\n");
-  fprintf(out,
-    "              [ -C controlfile ] [ -I infocode ] [ message ]\n");
+          "              [ -C controlfile ] [ -I infocode ] [ message ]\n");
 }
 
-
 /****************************************************************************
 
   printinfo
@@ -427,46 +425,44 @@ FILE *out;
 
 ****************************************************************************/
 
-void printinfo(infonum)
-int infonum;
+void printinfo(infonum) int infonum;
 {
   switch (infonum) {
-    case 0: /* Copyright message */
-      printf("FIGlet Copyright (C) 1991-2012 Glenn Chappell, Ian Chai, ");
-      printf("John Cowan,\nChristiaan Keet and Claudio Matsuoka\n");
-      printf("Internet: <info@figlet.org> ");
-      printf("Version: %s, date: %s\n\n",VERSION,DATE);
-      printf("FIGlet, along with the various FIGlet fonts");
-      printf(" and documentation, may be\n");
-      printf("freely copied and distributed.\n\n");
-      printf("If you use FIGlet, please send an");
-      printf(" e-mail message to <info@figlet.org>.\n\n");
-      printf("The latest version of FIGlet is available from the");
-      printf(" web site,\n\thttp://www.figlet.org/\n\n");
-      printusage(stdout);
-      break;
-    case 1: /* Version (integer) */
-      printf("%d\n",VERSION_INT);
-      break;
-    case 2: /* Font directory */
-      printf("%s\n",fontdirname);
-      break;
-    case 3: /* Font */
-      printf("%s\n",fontname);
-      break;
-    case 4: /* Outputwidth */
-      printf("%d\n",outputwidth);
-      break;
-    case 5: /* Font formats */
-      printf("%s", FONTFILEMAGICNUMBER);
+  case 0: /* Copyright message */
+    printf("FIGlet Copyright (C) 1991-2012 Glenn Chappell, Ian Chai, ");
+    printf("John Cowan,\nChristiaan Keet and Claudio Matsuoka\n");
+    printf("Internet: <info@figlet.org> ");
+    printf("Version: %s, date: %s\n\n", VERSION, DATE);
+    printf("FIGlet, along with the various FIGlet fonts");
+    printf(" and documentation, may be\n");
+    printf("freely copied and distributed.\n\n");
+    printf("If you use FIGlet, please send an");
+    printf(" e-mail message to <info@figlet.org>.\n\n");
+    printf("The latest version of FIGlet is available from the");
+    printf(" web site,\n\thttp://www.figlet.org/\n\n");
+    printusage(stdout);
+    break;
+  case 1: /* Version (integer) */
+    printf("%d\n", VERSION_INT);
+    break;
+  case 2: /* Font directory */
+    printf("%s\n", fontdirname);
+    break;
+  case 3: /* Font */
+    printf("%s\n", fontname);
+    break;
+  case 4: /* Outputwidth */
+    printf("%d\n", outputwidth);
+    break;
+  case 5: /* Font formats */
+    printf("%s", FONTFILEMAGICNUMBER);
 #ifdef TLF_FONTS
-      printf(" %s", TOILETFILEMAGICNUMBER);
+    printf(" %s", TOILETFILEMAGICNUMBER);
 #endif
-      printf("\n");
-    }
+    printf("\n");
+  }
 }
 
-
 /****************************************************************************
 
   readmagic
@@ -474,18 +470,17 @@ int infonum;
   Reads a four-character magic string from a stream.
 
 ****************************************************************************/
-void readmagic(fp,magic)
-ZFILE *fp;
+void readmagic(fp, magic) ZFILE *fp;
 char *magic;
 {
   int i;
 
-  for (i=0;i<4;i++) {
+  for (i = 0; i < 4; i++) {
     magic[i] = Zgetc(fp);
-    }
-  magic[4] = 0;
   }
-  
+  magic[4] = 0;
+}
+
 /****************************************************************************
 
   skipws
@@ -493,13 +488,13 @@ char *magic;
   Skips whitespace characters from a stream.
 
 ****************************************************************************/
-void skipws(fp)
-ZFILE *fp;
+void skipws(fp) ZFILE *fp;
 {
   int c;
-  while (c=Zgetc(fp),isascii(c)&&isspace(c)) ;
-  Zungetc(c,fp);
-  }
+  while (c = Zgetc(fp), isascii(c) && isspace(c))
+    ;
+  Zungetc(c, fp);
+}
 
 /****************************************************************************
 
@@ -509,8 +504,7 @@ ZFILE *fp;
   "0x" or "0X" for hexadecimal.  Ignores leading whitespace.
 
 ****************************************************************************/
-void readnum(fp,nump)
-ZFILE *fp;
+void readnum(fp, nump) ZFILE *fp;
 inchr *nump;
 {
   int acc = 0;
@@ -522,40 +516,37 @@ inchr *nump;
 
   skipws(fp);
   c = Zgetc(fp);
-  if (c=='-') {
+  if (c == '-') {
     sign = -1;
-    }
-  else {
-    Zungetc(c,fp);
-    }
+  } else {
+    Zungetc(c, fp);
+  }
   c = Zgetc(fp);
-  if (c=='0') {
-     c = Zgetc(fp);
-     if (c=='x'||c=='X') {
-       base = 16;
-       }
-     else {
-       base = 8;
-       Zungetc(c,fp);
-       }
-    }
-  else {
+  if (c == '0') {
+    c = Zgetc(fp);
+    if (c == 'x' || c == 'X') {
+      base = 16;
+    } else {
+      base = 8;
+      Zungetc(c, fp);
+    }
+  } else {
     base = 10;
-    Zungetc(c,fp);
-    }
+    Zungetc(c, fp);
+  }
 
-  while((c=Zgetc(fp))!=EOF) {
-    c=toupper(c);
-    p=strchr(digits,c);
+  while ((c = Zgetc(fp)) != EOF) {
+    c = toupper(c);
+    p = strchr(digits, c);
     if (!p) {
-      Zungetc(c,fp);
+      Zungetc(c, fp);
       *nump = acc * sign;
       return;
-      }
-    acc = acc*base+(p-digits);
     }
+    acc = acc * base + (p - digits);
+  }
   *nump = acc * sign;
-  }  
+}
 
 /****************************************************************************
 
@@ -574,38 +565,39 @@ ZFILE *fp;
   inchr thechar;
   char next;
 
-  thechar=Zgetc(fp);
-  if (thechar=='\n' || thechar=='\r') { /* Handle badly-formatted file */
-    Zungetc(thechar,fp);
+  thechar = Zgetc(fp);
+  if (thechar == '\n' || thechar == '\r') { /* Handle badly-formatted file */
+    Zungetc(thechar, fp);
     return '\0';
-    }
-  if (thechar!='\\') return thechar;
-  next=Zgetc(fp);
-  switch(next) {
-    case 'a':
-      return 7;
-    case 'b':
-      return 8;
-    case 'e':
-      return 27;
-    case 'f':
-      return 12;
-    case 'n':
-      return 10;
-    case 'r':
-      return 13;
-    case 't':
-      return 9;
-    case 'v':
-      return 11;
-    default:
-      if (next=='-' || next=='x' || (next>='0' && next<='9')) {
-        Zungetc(next,fp);
-        readnum(fp,&thechar);
-        return thechar;
-        }
-      return next;
-    }
+  }
+  if (thechar != '\\')
+    return thechar;
+  next = Zgetc(fp);
+  switch (next) {
+  case 'a':
+    return 7;
+  case 'b':
+    return 8;
+  case 'e':
+    return 27;
+  case 'f':
+    return 12;
+  case 'n':
+    return 10;
+  case 'r':
+    return 13;
+  case 't':
+    return 9;
+  case 'v':
+    return 11;
+  default:
+    if (next == '-' || next == 'x' || (next >= '0' && next <= '9')) {
+      Zungetc(next, fp);
+      readnum(fp, &thechar);
+      return thechar;
+    }
+    return next;
+  }
 }
 
 /****************************************************************************
@@ -625,10 +617,10 @@ ZFILE *fp;
   result = readTchar(fp);
   if (result == '\n' || result == '\r') {
     result = 0;
-    Zungetc(result,fp);
-    }
-  return result;
+    Zungetc(result, fp);
   }
+  return result;
+}
 
 /****************************************************************************
 
@@ -639,8 +631,7 @@ ZFILE *fp;
 
 ****************************************************************************/
 
-void charset(n, controlfile)
-int n;
+void charset(n, controlfile) int n;
 ZFILE *controlfile;
 {
   int ch;
@@ -649,40 +640,40 @@ ZFILE *controlfile;
   if (Zgetc(controlfile) != '9') {
     skiptoeol(controlfile);
     return;
-    }
+  }
   ch = Zgetc(controlfile);
   if (ch == '6') {
-     gn[n] = 65536L * charsetname(controlfile) + 0x80;
-     gndbl[n] = 0;
-     skiptoeol(controlfile);
-     return;
-     }
+    gn[n] = 65536L * charsetname(controlfile) + 0x80;
+    gndbl[n] = 0;
+    skiptoeol(controlfile);
+    return;
+  }
   if (ch != '4') {
     skiptoeol(controlfile);
     return;
-    }
+  }
   ch = Zgetc(controlfile);
   if (ch == 'x') {
-     if (Zgetc(controlfile) != '9') {
-       skiptoeol(controlfile);
-       return;
-       }
-     if (Zgetc(controlfile) != '4') {
-       skiptoeol(controlfile);
-       return;
-       }
-     skipws(controlfile);
-     gn[n] = 65536L * charsetname(controlfile);
-     gndbl[n] = 1;
-     skiptoeol(controlfile);
-     return;
-     }
+    if (Zgetc(controlfile) != '9') {
+      skiptoeol(controlfile);
+      return;
+    }
+    if (Zgetc(controlfile) != '4') {
+      skiptoeol(controlfile);
+      return;
+    }
+    skipws(controlfile);
+    gn[n] = 65536L * charsetname(controlfile);
+    gndbl[n] = 1;
+    skiptoeol(controlfile);
+    return;
+  }
   Zungetc(ch, controlfile);
   skipws(controlfile);
   gn[n] = 65536L * charsetname(controlfile);
   gndbl[n] = 0;
   return;
-  }
+}
 
 /****************************************************************************
 
@@ -693,7 +684,7 @@ ZFILE *controlfile;
 
 ****************************************************************************/
 
-ZFILE *FIGopen(name,suffix)
+ZFILE *FIGopen(name, suffix)
 char *name;
 char *suffix;
 {
@@ -703,26 +694,28 @@ char *suffix;
   int namelen;
 
   namelen = MYSTRLEN(fontdirname);
-  fontpath = (char*)alloca(sizeof(char)*
-    (namelen+MYSTRLEN(name)+MYSTRLEN(suffix)+2));
+  fontpath = (char *)alloca(sizeof(char) *
+                            (namelen + MYSTRLEN(name) + MYSTRLEN(suffix) + 2));
   fontfile = NULL;
-  if (!hasdirsep(name)) {  /* not a full path name */
-    strcpy(fontpath,fontdirname);
+  if (!hasdirsep(name)) { /* not a full path name */
+    strcpy(fontpath, fontdirname);
     fontpath[namelen] = DIRSEP;
-    fontpath[namelen+1] = '\0';
-    strcat(fontpath,name);
-    strcat(fontpath,suffix);
-    if(stat(fontpath,&st)==0) goto ok;
-    }
+    fontpath[namelen + 1] = '\0';
+    strcat(fontpath, name);
+    strcat(fontpath, suffix);
+    if (stat(fontpath, &st) == 0)
+      goto ok;
+  }
   /* just append suffix */
-  strcpy(fontpath,name);
-  strcat(fontpath,suffix);
-  if(stat(fontpath,&st)==0) goto ok;
+  strcpy(fontpath, name);
+  strcat(fontpath, suffix);
+  if (stat(fontpath, &st) == 0)
+    goto ok;
 
   return NULL;
 
 ok:
-  fontfile = Zopen(fontpath,"rb");
+  fontfile = Zopen(fontpath, "rb");
   return fontfile;
 }
 
@@ -735,129 +728,137 @@ ok:
 
 ****************************************************************************/
 
-void readcontrol(controlname)
-char *controlname;
+void readcontrol(controlname) char *controlname;
 {
-  inchr firstch,lastch;
+  inchr firstch, lastch;
   char dashcheck;
   inchr offset;
   int command;
   ZFILE *controlfile;
 
-  controlfile = FIGopen(controlname,CONTROLFILESUFFIX);
+  controlfile = FIGopen(controlname, CONTROLFILESUFFIX);
 
-  if (controlfile==NULL) {
-    fprintf(stderr,"%s: %s: Unable to open control file\n",myname,
-      controlname);
+  if (controlfile == NULL) {
+    fprintf(stderr, "%s: %s: Unable to open control file\n", myname,
+            controlname);
     exit(1);
-    }
+  }
 
-  (*commandlistend) = (comnode*)myalloc(sizeof(comnode));
+  (*commandlistend) = (comnode *)myalloc(sizeof(comnode));
   (*commandlistend)->thecommand = 0; /* Begin with a freeze command */
   commandlistend = &(*commandlistend)->next;
   (*commandlistend) = NULL;
 
-  while(command=Zgetc(controlfile),command!=EOF) {
+  while (command = Zgetc(controlfile), command != EOF) {
     switch (command) {
-      case 't': /* Translate */
-        skipws(controlfile);
-        firstch=readTchar(controlfile);
-        if ((dashcheck=Zgetc(controlfile))=='-') {
-          lastch=readTchar(controlfile);
-          }
-        else {
-          Zungetc(dashcheck,controlfile);
-          lastch=firstch;
-          }
-        skipws(controlfile);
-        offset=readTchar(controlfile)-firstch;
-        skiptoeol(controlfile);
-        (*commandlistend) = (comnode*)myalloc(sizeof(comnode));
-        (*commandlistend)->thecommand = 1;
-        (*commandlistend)->rangelo = firstch;
-        (*commandlistend)->rangehi = lastch;
-        (*commandlistend)->offset = offset;
-        commandlistend = &(*commandlistend)->next;
-        (*commandlistend) = NULL;
-        break;
-      case '0': case '1': case '2': case '3': case '4':
-      case '5': case '6': case '7': case '8': case '9':
-      case '-':
-                /* Mapping table entry */
-        Zungetc(command,controlfile);
-        readnum(controlfile,&firstch);
-        skipws(controlfile);
-	readnum(controlfile,&lastch);
-	offset=lastch-firstch;
-        lastch=firstch;
-        skiptoeol(controlfile);
-        (*commandlistend) = (comnode*)myalloc(sizeof(comnode));
-        (*commandlistend)->thecommand = 1;
-        (*commandlistend)->rangelo = firstch;
-        (*commandlistend)->rangehi = lastch;
-        (*commandlistend)->offset = offset;
-        commandlistend = &(*commandlistend)->next;
-        (*commandlistend) = NULL;
-        break;
-      case 'f': /* freeze */
-        skiptoeol(controlfile);
-        (*commandlistend) = (comnode*)myalloc(sizeof(comnode));
-        (*commandlistend)->thecommand = 0;
-        commandlistend = &(*commandlistend)->next;
-        (*commandlistend) = NULL;
+    case 't': /* Translate */
+      skipws(controlfile);
+      firstch = readTchar(controlfile);
+      if ((dashcheck = Zgetc(controlfile)) == '-') {
+        lastch = readTchar(controlfile);
+      } else {
+        Zungetc(dashcheck, controlfile);
+        lastch = firstch;
+      }
+      skipws(controlfile);
+      offset = readTchar(controlfile) - firstch;
+      skiptoeol(controlfile);
+      (*commandlistend) = (comnode *)myalloc(sizeof(comnode));
+      (*commandlistend)->thecommand = 1;
+      (*commandlistend)->rangelo = firstch;
+      (*commandlistend)->rangehi = lastch;
+      (*commandlistend)->offset = offset;
+      commandlistend = &(*commandlistend)->next;
+      (*commandlistend) = NULL;
+      break;
+    case '0':
+    case '1':
+    case '2':
+    case '3':
+    case '4':
+    case '5':
+    case '6':
+    case '7':
+    case '8':
+    case '9':
+    case '-':
+      /* Mapping table entry */
+      Zungetc(command, controlfile);
+      readnum(controlfile, &firstch);
+      skipws(controlfile);
+      readnum(controlfile, &lastch);
+      offset = lastch - firstch;
+      lastch = firstch;
+      skiptoeol(controlfile);
+      (*commandlistend) = (comnode *)myalloc(sizeof(comnode));
+      (*commandlistend)->thecommand = 1;
+      (*commandlistend)->rangelo = firstch;
+      (*commandlistend)->rangehi = lastch;
+      (*commandlistend)->offset = offset;
+      commandlistend = &(*commandlistend)->next;
+      (*commandlistend) = NULL;
+      break;
+    case 'f': /* freeze */
+      skiptoeol(controlfile);
+      (*commandlistend) = (comnode *)myalloc(sizeof(comnode));
+      (*commandlistend)->thecommand = 0;
+      commandlistend = &(*commandlistend)->next;
+      (*commandlistend) = NULL;
+      break;
+    case 'b': /* DBCS input mode */
+      multibyte = 1;
+      break;
+    case 'u': /* UTF-8 input mode */
+      multibyte = 2;
+      break;
+    case 'h': /* HZ input mode */
+      multibyte = 3;
+      break;
+    case 'j': /* Shift-JIS input mode */
+      multibyte = 4;
+      break;
+    case 'g': /* ISO 2022 character set choices */
+      multibyte = 0;
+      skipws(controlfile);
+      command = Zgetc(controlfile);
+      switch (command) {
+      case '0': /* define G0 charset */
+        charset(0, controlfile);
         break;
-      case 'b': /* DBCS input mode */
-        multibyte = 1;
+      case '1': /* set G1 charset */
+        charset(1, controlfile);
         break;
-      case 'u': /* UTF-8 input mode */
-        multibyte = 2;
+      case '2': /* set G2 charset */
+        charset(2, controlfile);
         break;
-      case 'h': /* HZ input mode */
-        multibyte = 3;
+      case '3': /* set G3 charset */
+        charset(3, controlfile);
         break;
-      case 'j': /* Shift-JIS input mode */
-        multibyte = 4;
+      case 'l':
+      case 'L': /* define left half */
+        skipws(controlfile);
+        gl = Zgetc(controlfile) - '0';
+        skiptoeol(controlfile);
         break;
-      case 'g': /* ISO 2022 character set choices */
-        multibyte = 0;
+      case 'r':
+      case 'R': /* define right half */
         skipws(controlfile);
-        command=Zgetc(controlfile);
-        switch (command) {
-          case '0': /* define G0 charset */
-            charset(0, controlfile);
-            break;
-          case '1': /* set G1 charset */
-            charset(1, controlfile);
-            break;
-          case '2': /* set G2 charset */
-            charset(2, controlfile);
-            break;
-          case '3': /* set G3 charset */
-            charset(3, controlfile);
-            break;
-          case 'l': case 'L': /* define left half */
-            skipws(controlfile);
-            gl = Zgetc(controlfile) - '0';
-            skiptoeol(controlfile);
-            break;
-          case 'r': case 'R': /* define right half */
-            skipws(controlfile);
-            gr = Zgetc(controlfile) - '0';
-            skiptoeol(controlfile);
-            break;
-          default: /* meaningless "g" command */
-            skiptoeol(controlfile);
-          }
-      case '\r': case '\n': /* blank line */
+        gr = Zgetc(controlfile) - '0';
+        skiptoeol(controlfile);
         break;
-      default: /* Includes '#' */
+      default: /* meaningless "g" command */
         skiptoeol(controlfile);
       }
+    case '\r':
+    case '\n': /* blank line */
+      break;
+    default: /* Includes '#' */
+      skiptoeol(controlfile);
     }
+  }
   Zclose(controlfile);
 }
 
-
 /****************************************************************************
 
   readcontrolfiles
@@ -867,16 +868,14 @@ char *controlname;
 
 ****************************************************************************/
 
-void readcontrolfiles()
-{
+void readcontrolfiles() {
   cfnamenode *cfnptr;
 
-  for (cfnptr=cfilelist;cfnptr!=NULL;cfnptr=cfnptr->next) {
+  for (cfnptr = cfilelist; cfnptr != NULL; cfnptr = cfnptr->next) {
     readcontrol(cfnptr->thename);
-    }
+  }
 }
 
-
 /****************************************************************************
 
   clearcfilelist
@@ -885,21 +884,19 @@ void readcontrolfiles()
 
 ****************************************************************************/
 
-void clearcfilelist()
-{
-  cfnamenode *cfnptr1,*cfnptr2;
+void clearcfilelist() {
+  cfnamenode *cfnptr1, *cfnptr2;
 
   cfnptr1 = cfilelist;
   while (cfnptr1 != NULL) {
     cfnptr2 = cfnptr1->next;
     free(cfnptr1);
     cfnptr1 = cfnptr2;
-    }
+  }
   cfilelist = NULL;
   cfilelistend = &cfilelist;
 }
 
-
 /****************************************************************************
 
   getparams
@@ -909,25 +906,23 @@ void clearcfilelist()
 
 ****************************************************************************/
 
-void getparams()
-{
+void getparams() {
   extern char *optarg;
   extern int optind;
   int c; /* "Should" be a char -- need int for "!= -1" test*/
-  int columns,infoprint;
-  char *controlname,*env;
+  int columns, infoprint;
+  char *controlname, *env;
 
-  if ((myname = strrchr(Myargv[0],DIRSEP))!=NULL) {
+  if ((myname = strrchr(Myargv[0], DIRSEP)) != NULL) {
     myname++;
-    }
-  else {
+  } else {
     myname = Myargv[0];
-    }
+  }
   fontdirname = DEFAULTFONTDIR;
   env = getenv("FIGLET_FONTDIR");
-  if (env!=NULL) {
+  if (env != NULL) {
     fontdirname = env;
-    }
+  }
   fontname = DEFAULTFONTFILE;
   cfilelist = NULL;
   cfilelistend = &cfilelist;
@@ -943,160 +938,164 @@ void getparams()
   outputwidth = DEFAULTCOLUMNS;
   gn[1] = 0x80;
   gr = 1;
-  while ((c = getopt(Myargc,Myargv,"ADEXLRI:xlcrpntvm:w:d:f:C:NFskSWo"))!= -1) {
-      /* Note: -F is not a legal option -- prints a special err message.  */
+  while ((c = getopt(Myargc, Myargv, "ADEXLRI:xlcrpntvm:w:d:f:C:NFskSWo")) !=
+         -1) {
+    /* Note: -F is not a legal option -- prints a special err message.  */
     switch (c) {
-      case 'A':
-        cmdinput = 1;
-        break;
-      case 'D':
-        deutschflag = 1;
-        break;
-      case 'E':
-        deutschflag = 0;
-        break;
-      case 'X':
-        right2left = -1;
-        break;
-      case 'L':
-        right2left = 0;
-        break;
-      case 'R':
-        right2left = 1;
-        break;
-      case 'x':
-        justification = -1;
-        break;
-      case 'l':
-        justification = 0;
-        break;
-      case 'c':
-        justification = 1;
-        break;
-      case 'r':
-        justification = 2;
-        break;
-      case 'p':
-        paragraphflag = 1;
-        break;
-      case 'n':
-        paragraphflag = 0;
-        break;
-      case 's':
+    case 'A':
+      cmdinput = 1;
+      break;
+    case 'D':
+      deutschflag = 1;
+      break;
+    case 'E':
+      deutschflag = 0;
+      break;
+    case 'X':
+      right2left = -1;
+      break;
+    case 'L':
+      right2left = 0;
+      break;
+    case 'R':
+      right2left = 1;
+      break;
+    case 'x':
+      justification = -1;
+      break;
+    case 'l':
+      justification = 0;
+      break;
+    case 'c':
+      justification = 1;
+      break;
+    case 'r':
+      justification = 2;
+      break;
+    case 'p':
+      paragraphflag = 1;
+      break;
+    case 'n':
+      paragraphflag = 0;
+      break;
+    case 's':
+      smushoverride = SMO_NO;
+      break;
+    case 'k':
+      smushmode = SM_KERN;
+      smushoverride = SMO_YES;
+      break;
+    case 'S':
+      smushmode = SM_SMUSH;
+      smushoverride = SMO_FORCE;
+      break;
+    case 'o':
+      smushmode = SM_SMUSH;
+      smushoverride = SMO_YES;
+      break;
+    case 'W':
+      smushmode = 0;
+      smushoverride = SMO_YES;
+      break;
+    case 't':
+#ifdef TIOCGWINSZ
+      columns = get_columns();
+      if (columns > 0) {
+        outputwidth = columns;
+      }
+#else  /* ifdef TIOCGWINSZ */
+      fprintf(stderr,
+              "%s: \"-t\" is disabled, since ioctl is not fully implemented.\n",
+              myname);
+#endif /* ifdef TIOCGWINSZ */
+      break;
+    case 'v':
+      infoprint = 0;
+      break;
+    case 'I':
+      infoprint = atoi(optarg);
+      break;
+    case 'm':
+      smushmode = atoi(optarg);
+      if (smushmode < -1) {
         smushoverride = SMO_NO;
         break;
-      case 'k':
+      }
+      if (smushmode == 0)
         smushmode = SM_KERN;
-        smushoverride = SMO_YES;
-        break;
-      case 'S':
-        smushmode = SM_SMUSH;
-	smushoverride = SMO_FORCE;
-        break;
-      case 'o':
-        smushmode = SM_SMUSH;
-	smushoverride = SMO_YES;
-        break;
-      case 'W':
+      else if (smushmode == -1)
         smushmode = 0;
-	smushoverride = SMO_YES;
-        break;
-      case 't':
-#ifdef TIOCGWINSZ
-        columns = get_columns();
-        if (columns>0) {
-          outputwidth = columns;
-          }
-#else /* ifdef TIOCGWINSZ */
-        fprintf(stderr,
-          "%s: \"-t\" is disabled, since ioctl is not fully implemented.\n",
-          myname);
-#endif /* ifdef TIOCGWINSZ */
-        break;
-      case 'v':
-        infoprint = 0;
-        break;
-      case 'I':
-        infoprint = atoi(optarg);
-        break;
-      case 'm':
-        smushmode = atoi(optarg);
-        if (smushmode < -1) {
-          smushoverride = SMO_NO;
-          break;
-          }
-	if (smushmode == 0) smushmode = SM_KERN;
-	else if (smushmode == -1) smushmode = 0;
-	else smushmode = (smushmode & 63) | SM_SMUSH;
-	smushoverride = SMO_YES;
-        break;
-      case 'w':
-        columns = atoi(optarg);
-        if (columns>0) {
-          outputwidth = columns;
-          }
-        break;
-      case 'd':
-        fontdirname = optarg;
-        break;
-      case 'f':
-        fontname = optarg;
-        if (suffixcmp(fontname,FONTFILESUFFIX)) {
-          fontname[MYSTRLEN(fontname)-FSUFFIXLEN] = '\0';
-          }
+      else
+        smushmode = (smushmode & 63) | SM_SMUSH;
+      smushoverride = SMO_YES;
+      break;
+    case 'w':
+      columns = atoi(optarg);
+      if (columns > 0) {
+        outputwidth = columns;
+      }
+      break;
+    case 'd':
+      fontdirname = optarg;
+      break;
+    case 'f':
+      fontname = optarg;
+      if (suffixcmp(fontname, FONTFILESUFFIX)) {
+        fontname[MYSTRLEN(fontname) - FSUFFIXLEN] = '\0';
+      }
 #ifdef TLF_FONTS
-        else if (suffixcmp(fontname,TOILETFILESUFFIX)) {
-          fontname[MYSTRLEN(fontname)-TSUFFIXLEN] = '\0';
-          }
+      else if (suffixcmp(fontname, TOILETFILESUFFIX)) {
+        fontname[MYSTRLEN(fontname) - TSUFFIXLEN] = '\0';
+      }
 #endif
-        break;
-      case 'C':
-        controlname = optarg;
-        if (suffixcmp(controlname, CONTROLFILESUFFIX)) {
-          controlname[MYSTRLEN(controlname)-CSUFFIXLEN] = '\0';
-          }
-        (*cfilelistend) = (cfnamenode*)myalloc(sizeof(cfnamenode));
-        (*cfilelistend)->thename = controlname;
-        cfilelistend = &(*cfilelistend)->next;
-        (*cfilelistend) = NULL;
-        break;
-      case 'N':
-        clearcfilelist();
-        multibyte = 0;
-        gn[0] = 0;
-        gn[1] = 0x80;
-        gn[2] = gn[3] = 0;
-        gndbl[0] = gndbl[1] = gndbl[2] = gndbl[3] = 0;
-        gl = 0;
-        gr = 1;
-        break;
-      case 'F': /* Not a legal option */
-        fprintf(stderr,"%s: illegal option -- F\n",myname);
-        printusage(stderr);
-        fprintf(stderr,"\nBecause of numerous incompatibilities, the");
-        fprintf(stderr," \"-F\" option has been\n");
-        fprintf(stderr,"removed.  It has been replaced by the \"figlist\"");
-        fprintf(stderr," program, which is now\n");
-        fprintf(stderr,"included in the basic FIGlet package.  \"figlist\"");
-        fprintf(stderr," is also available\n");
-        fprintf(stderr,"from  http://www.figlet.org/");
-        fprintf(stderr,"under UNIX utilities.\n");
-        exit(1);
-        break;
-      default:
-        printusage(stderr);
-        exit(1);
+      break;
+    case 'C':
+      controlname = optarg;
+      if (suffixcmp(controlname, CONTROLFILESUFFIX)) {
+        controlname[MYSTRLEN(controlname) - CSUFFIXLEN] = '\0';
       }
+      (*cfilelistend) = (cfnamenode *)myalloc(sizeof(cfnamenode));
+      (*cfilelistend)->thename = controlname;
+      cfilelistend = &(*cfilelistend)->next;
+      (*cfilelistend) = NULL;
+      break;
+    case 'N':
+      clearcfilelist();
+      multibyte = 0;
+      gn[0] = 0;
+      gn[1] = 0x80;
+      gn[2] = gn[3] = 0;
+      gndbl[0] = gndbl[1] = gndbl[2] = gndbl[3] = 0;
+      gl = 0;
+      gr = 1;
+      break;
+    case 'F': /* Not a legal option */
+      fprintf(stderr, "%s: illegal option -- F\n", myname);
+      printusage(stderr);
+      fprintf(stderr, "\nBecause of numerous incompatibilities, the");
+      fprintf(stderr, " \"-F\" option has been\n");
+      fprintf(stderr, "removed.  It has been replaced by the \"figlist\"");
+      fprintf(stderr, " program, which is now\n");
+      fprintf(stderr, "included in the basic FIGlet package.  \"figlist\"");
+      fprintf(stderr, " is also available\n");
+      fprintf(stderr, "from  http://www.figlet.org/");
+      fprintf(stderr, "under UNIX utilities.\n");
+      exit(1);
+      break;
+    default:
+      printusage(stderr);
+      exit(1);
     }
-  if (optind!=Myargc) cmdinput = 1; /* force cmdinput if more arguments */
-  outlinelenlimit = outputwidth-1;
-  if (infoprint>=0) {
+  }
+  if (optind != Myargc)
+    cmdinput = 1; /* force cmdinput if more arguments */
+  outlinelenlimit = outputwidth - 1;
+  if (infoprint >= 0) {
     printinfo(infoprint);
     exit(0);
-    }
+  }
 }
 
-
 /****************************************************************************
 
   clearline
@@ -1105,18 +1104,16 @@ void getparams()
 
 ****************************************************************************/
 
-void clearline()
-{
+void clearline() {
   int i;
 
-  for (i=0;i<charheight;i++) {
+  for (i = 0; i < charheight; i++) {
     outputline[i][0] = '\0';
-    }
+  }
   outlinelen = 0;
   inchrlinelen = 0;
 }
 
-
 /****************************************************************************
 
   readfontchar
@@ -1126,49 +1123,48 @@ void clearline()
 
 ****************************************************************************/
 
-void readfontchar(file,theord)
-ZFILE *file;
+void readfontchar(file, theord) ZFILE *file;
 inchr theord;
 {
-  int row,k;
-  char templine[MAXLEN+1];
-  outchr endchar, outline[MAXLEN+1];
+  int row, k;
+  char templine[MAXLEN + 1];
+  outchr endchar, outline[MAXLEN + 1];
   fcharnode *fclsave;
 
   fclsave = fcharlist;
-  fcharlist = (fcharnode*)myalloc(sizeof(fcharnode));
+  fcharlist = (fcharnode *)myalloc(sizeof(fcharnode));
   fcharlist->ord = theord;
-  fcharlist->thechar = (outchr**)myalloc(sizeof(outchr*)*charheight);
+  fcharlist->thechar = (outchr **)myalloc(sizeof(outchr *) * charheight);
   fcharlist->next = fclsave;
 
   outline[0] = 0;
 
-  for (row=0;row<charheight;row++) {
-    if (myfgets(templine,MAXLEN,file)==NULL) {
+  for (row = 0; row < charheight; row++) {
+    if (myfgets(templine, MAXLEN, file) == NULL) {
       templine[0] = '\0';
-      }
+    }
 #ifdef TLF_FONTS
-    utf8_to_wchar(templine,MAXLEN,outline,MAXLEN,0);
+    utf8_to_wchar(templine, MAXLEN, outline, MAXLEN, 0);
 #else
-    strcpy(outline,templine);
+    strcpy(outline, templine);
 #endif
-    k = STRLEN(outline)-1;
-    while (k>=0 && ISSPACE(outline[k])) {  /* remove trailing spaces */
+    k = STRLEN(outline) - 1;
+    while (k >= 0 && ISSPACE(outline[k])) { /* remove trailing spaces */
       k--;
-      }
-    if (k>=0) {
-      endchar = outline[k];  /* remove endmarks */
-      while (k>=0 && outline[k]==endchar) {
+    }
+    if (k >= 0) {
+      endchar = outline[k]; /* remove endmarks */
+      while (k >= 0 && outline[k] == endchar) {
         k--;
-        }
       }
-    outline[k+1] = '\0';
-    fcharlist->thechar[row] = (outchr*)myalloc(sizeof(outchr)*(STRLEN(outline)+1));
-    STRCPY(fcharlist->thechar[row],outline);
     }
+    outline[k + 1] = '\0';
+    fcharlist->thechar[row] =
+        (outchr *)myalloc(sizeof(outchr) * (STRLEN(outline) + 1));
+    STRCPY(fcharlist->thechar[row], outline);
+  }
 }
 
-
 /****************************************************************************
 
   readfont
@@ -1178,112 +1174,115 @@ inchr theord;
 
 ****************************************************************************/
 
-void readfont()
-{
-  int i,row,numsread;
+void readfont() {
+  int i, row, numsread;
   inchr theord;
-  int maxlen,cmtlines,ffright2left;
-  int smush,smush2;
-  char fileline[MAXLEN+1],magicnum[5];
+  int maxlen, cmtlines, ffright2left;
+  int smush, smush2;
+  char fileline[MAXLEN + 1], magicnum[5];
   ZFILE *fontfile;
 
-  fontfile = FIGopen(fontname,FONTFILESUFFIX);
+  fontfile = FIGopen(fontname, FONTFILESUFFIX);
 #ifdef TLF_FONTS
-  if (fontfile==NULL) {
-    fontfile = FIGopen(fontname,TOILETFILESUFFIX);
-    if(fontfile) toiletfont = 1;
-    }
+  if (fontfile == NULL) {
+    fontfile = FIGopen(fontname, TOILETFILESUFFIX);
+    if (fontfile)
+      toiletfont = 1;
+  }
 #endif
 
-  if (fontfile==NULL) {
-    fprintf(stderr,"%s: %s: Unable to open font file\n",myname,fontname);
+  if (fontfile == NULL) {
+    fprintf(stderr, "%s: %s: Unable to open font file\n", myname, fontname);
     exit(1);
-    }
+  }
 
-  readmagic(fontfile,magicnum);
-  if (myfgets(fileline,MAXLEN,fontfile)==NULL) {
+  readmagic(fontfile, magicnum);
+  if (myfgets(fileline, MAXLEN, fontfile) == NULL) {
     fileline[0] = '\0';
-    }
-  if (MYSTRLEN(fileline)>0 ? fileline[MYSTRLEN(fileline)-1]!='\n' : 0) {
+  }
+  if (MYSTRLEN(fileline) > 0 ? fileline[MYSTRLEN(fileline) - 1] != '\n' : 0) {
     skiptoeol(fontfile);
-    }
-  numsread = sscanf(fileline,"%*c%c %d %*d %d %d %d %d %d",
-    &hardblank,&charheight,&maxlen,&smush,&cmtlines,
-    &ffright2left,&smush2);
+  }
+  numsread =
+      sscanf(fileline, "%*c%c %d %*d %d %d %d %d %d", &hardblank, &charheight,
+             &maxlen, &smush, &cmtlines, &ffright2left, &smush2);
 
   if (maxlen > MAXLEN) {
-    fprintf(stderr,"%s: %s: character is too wide\n",myname,fontname);
+    fprintf(stderr, "%s: %s: character is too wide\n", myname, fontname);
     exit(1);
-    }
+  }
 #ifdef TLF_FONTS
-  if ((!toiletfont && strcmp(magicnum,FONTFILEMAGICNUMBER)) ||
-      (toiletfont && strcmp(magicnum,TOILETFILEMAGICNUMBER)) || numsread<5) {
+  if ((!toiletfont && strcmp(magicnum, FONTFILEMAGICNUMBER)) ||
+      (toiletfont && strcmp(magicnum, TOILETFILEMAGICNUMBER)) || numsread < 5) {
 #else
-  if (strcmp(magicnum,FONTFILEMAGICNUMBER) || numsread<5) {
+  if (strcmp(magicnum, FONTFILEMAGICNUMBER) || numsread < 5) {
 #endif
-    fprintf(stderr,"%s: %s: Not a FIGlet 2 font file\n",myname,fontname);
+    fprintf(stderr, "%s: %s: Not a FIGlet 2 font file\n", myname, fontname);
     exit(1);
-    }
-  for (i=1;i<=cmtlines;i++) {
+  }
+  for (i = 1; i <= cmtlines; i++) {
     skiptoeol(fontfile);
-    }
+  }
 
-  if (numsread<6) {
+  if (numsread < 6) {
     ffright2left = 0;
-    }
+  }
 
-  if (numsread<7) { /* if no smush2, decode smush into smush2 */
-    if (smush == 0) smush2 = SM_KERN;
-    else if (smush < 0) smush2 = 0;
-    else smush2 = (smush & 31) | SM_SMUSH;
-    }
+  if (numsread < 7) { /* if no smush2, decode smush into smush2 */
+    if (smush == 0)
+      smush2 = SM_KERN;
+    else if (smush < 0)
+      smush2 = 0;
+    else
+      smush2 = (smush & 31) | SM_SMUSH;
+  }
 
-  if (charheight<1) {
+  if (charheight < 1) {
     charheight = 1;
-    }
+  }
 
-  if (maxlen<1) {
+  if (maxlen < 1) {
     maxlen = 1;
-    }
+  }
 
   maxlen += 100; /* Give ourselves some extra room */
 
   if (smushoverride == SMO_NO)
-     smushmode = smush2;
+    smushmode = smush2;
   else if (smushoverride == SMO_FORCE)
-     smushmode |= smush2;
+    smushmode |= smush2;
 
-  if (right2left<0) {
+  if (right2left < 0) {
     right2left = ffright2left;
-    }
+  }
 
-  if (justification<0) {
-    justification = 2*right2left;
-    }
+  if (justification < 0) {
+    justification = 2 * right2left;
+  }
 
   /* Allocate "missing" character */
-  fcharlist = (fcharnode*)myalloc(sizeof(fcharnode));
+  fcharlist = (fcharnode *)myalloc(sizeof(fcharnode));
   fcharlist->ord = 0;
-  fcharlist->thechar = (outchr**)myalloc(sizeof(outchr*)*charheight);
+  fcharlist->thechar = (outchr **)myalloc(sizeof(outchr *) * charheight);
   fcharlist->next = NULL;
-  for (row=0;row<charheight;row++) {
-    fcharlist->thechar[row] = (outchr*)myalloc(sizeof(outchr));
+  for (row = 0; row < charheight; row++) {
+    fcharlist->thechar[row] = (outchr *)myalloc(sizeof(outchr));
     fcharlist->thechar[row][0] = '\0';
-    }
-  for (theord=' ';theord<='~';theord++) {
-    readfontchar(fontfile,theord);
-    }
-  for (theord=0;theord<=6;theord++) {
-    readfontchar(fontfile,deutsch[theord]);
-    }
-  while (myfgets(fileline,maxlen+1,fontfile)==NULL?0:
-    sscanf(fileline,"%li",&theord)==1) {
-    readfontchar(fontfile,theord);
-    }
+  }
+  for (theord = ' '; theord <= '~'; theord++) {
+    readfontchar(fontfile, theord);
+  }
+  for (theord = 0; theord <= 6; theord++) {
+    readfontchar(fontfile, deutsch[theord]);
+  }
+  while (myfgets(fileline, maxlen + 1, fontfile) == NULL
+             ? 0
+             : sscanf(fileline, "%li", &theord) == 1) {
+    readfontchar(fontfile, theord);
+  }
   Zclose(fontfile);
 }
 
-
 /****************************************************************************
 
   linealloc
@@ -1293,20 +1292,18 @@ void readfont()
 
 ****************************************************************************/
 
-void linealloc()
-{
-  int row; 
+void linealloc() {
+  int row;
 
-  outputline = (outchr**)myalloc(sizeof(outchr*)*charheight);
-  for (row=0;row<charheight;row++) {
-    outputline[row] = (outchr*)myalloc(sizeof(outchr)*(outlinelenlimit+1));
-    }
-  inchrlinelenlimit = outputwidth*4+100;
-  inchrline = (inchr*)myalloc(sizeof(inchr)*(inchrlinelenlimit+1));
+  outputline = (outchr **)myalloc(sizeof(outchr *) * charheight);
+  for (row = 0; row < charheight; row++) {
+    outputline[row] = (outchr *)myalloc(sizeof(outchr) * (outlinelenlimit + 1));
+  }
+  inchrlinelenlimit = outputwidth * 4 + 100;
+  inchrline = (inchr *)myalloc(sizeof(inchr) * (inchrlinelenlimit + 1));
   clearline();
 }
 
-
 /****************************************************************************
 
   getletter
@@ -1316,26 +1313,25 @@ void linealloc()
 
 ****************************************************************************/
 
-void getletter(c)
-inchr c;
+void getletter(c) inchr c;
 {
   fcharnode *charptr;
 
-  for (charptr=fcharlist;charptr==NULL?0:charptr->ord!=c;
-    charptr=charptr->next) ;
-  if (charptr!=NULL) {
+  for (charptr = fcharlist; charptr == NULL ? 0 : charptr->ord != c;
+       charptr = charptr->next)
+    ;
+  if (charptr != NULL) {
     currchar = charptr->thechar;
-    }
-  else {
-    for (charptr=fcharlist;charptr==NULL?0:charptr->ord!=0;
-      charptr=charptr->next) ;
+  } else {
+    for (charptr = fcharlist; charptr == NULL ? 0 : charptr->ord != 0;
+         charptr = charptr->next)
+      ;
     currchar = charptr->thechar;
-    }
+  }
   previouscharwidth = currcharwidth;
   currcharwidth = STRLEN(currchar[0]);
 }
 
-
 /****************************************************************************
 
   smushem
@@ -1355,17 +1351,21 @@ inchr c;
 
 ****************************************************************************/
 
-outchr smushem(lch,rch)
-outchr lch,rch;
+outchr smushem(lch, rch)
+outchr lch, rch;
 {
-  if (lch==' ') return rch;
-  if (rch==' ') return lch;
+  if (lch == ' ')
+    return rch;
+  if (rch == ' ')
+    return lch;
 
-  if (previouscharwidth<2 || currcharwidth<2) return '\0';
-    /* Disallows overlapping if the previous character */
-    /* or the current character has a width of 1 or zero. */
+  if (previouscharwidth < 2 || currcharwidth < 2)
+    return '\0';
+  /* Disallows overlapping if the previous character */
+  /* or the current character has a width of 1 or zero. */
 
-  if ((smushmode & SM_SMUSH) == 0) return '\0';  /* kerning */
+  if ((smushmode & SM_SMUSH) == 0)
+    return '\0'; /* kerning */
 
   if ((smushmode & 63) == 0) {
     /* This is smushing by universal overlapping. */
@@ -1374,66 +1374,92 @@ outchr lch,rch;
     if (rch==' ') return lch;
     */
 
-    if (lch==hardblank) return rch;
-    if (rch==hardblank) return lch;
-      /* Above four lines ensure overlapping preference to */
-      /* visible characters. */
-    if (right2left==1) return lch;
-      /* Above line ensures that the dominant (foreground) */
-      /* fig-character for overlapping is the latter in the */
-      /* user's text, not necessarily the rightmost character. */
+    if (lch == hardblank)
+      return rch;
+    if (rch == hardblank)
+      return lch;
+    /* Above four lines ensure overlapping preference to */
+    /* visible characters. */
+    if (right2left == 1)
+      return lch;
+    /* Above line ensures that the dominant (foreground) */
+    /* fig-character for overlapping is the latter in the */
+    /* user's text, not necessarily the rightmost character. */
     return rch;
-      /* Occurs in the absence of above exceptions. */
-    }
-  
+    /* Occurs in the absence of above exceptions. */
+  }
+
   if (smushmode & SM_HARDBLANK) {
-    if (lch==hardblank && rch==hardblank) return lch;
-    }
+    if (lch == hardblank && rch == hardblank)
+      return lch;
+  }
 
-  if (lch==hardblank || rch==hardblank) return '\0';
+  if (lch == hardblank || rch == hardblank)
+    return '\0';
 
   if (smushmode & SM_EQUAL) {
-    if (lch==rch) return lch;
-    }
+    if (lch == rch)
+      return lch;
+  }
 
   if (smushmode & SM_LOWLINE) {
-    if (lch=='_' && strchr("|/\\[]{}()<>",rch)) return rch;
-    if (rch=='_' && strchr("|/\\[]{}()<>",lch)) return lch;
-    }
+    if (lch == '_' && strchr("|/\\[]{}()<>", rch))
+      return rch;
+    if (rch == '_' && strchr("|/\\[]{}()<>", lch))
+      return lch;
+  }
 
   if (smushmode & SM_HIERARCHY) {
-    if (lch=='|' && strchr("/\\[]{}()<>",rch)) return rch;
-    if (rch=='|' && strchr("/\\[]{}()<>",lch)) return lch;
-    if (strchr("/\\",lch) && strchr("[]{}()<>",rch)) return rch;
-    if (strchr("/\\",rch) && strchr("[]{}()<>",lch)) return lch;
-    if (strchr("[]",lch) && strchr("{}()<>",rch)) return rch;
-    if (strchr("[]",rch) && strchr("{}()<>",lch)) return lch;
-    if (strchr("{}",lch) && strchr("()<>",rch)) return rch;
-    if (strchr("{}",rch) && strchr("()<>",lch)) return lch;
-    if (strchr("()",lch) && strchr("<>",rch)) return rch;
-    if (strchr("()",rch) && strchr("<>",lch)) return lch;
-    }
+    if (lch == '|' && strchr("/\\[]{}()<>", rch))
+      return rch;
+    if (rch == '|' && strchr("/\\[]{}()<>", lch))
+      return lch;
+    if (strchr("/\\", lch) && strchr("[]{}()<>", rch))
+      return rch;
+    if (strchr("/\\", rch) && strchr("[]{}()<>", lch))
+      return lch;
+    if (strchr("[]", lch) && strchr("{}()<>", rch))
+      return rch;
+    if (strchr("[]", rch) && strchr("{}()<>", lch))
+      return lch;
+    if (strchr("{}", lch) && strchr("()<>", rch))
+      return rch;
+    if (strchr("{}", rch) && strchr("()<>", lch))
+      return lch;
+    if (strchr("()", lch) && strchr("<>", rch))
+      return rch;
+    if (strchr("()", rch) && strchr("<>", lch))
+      return lch;
+  }
 
   if (smushmode & SM_PAIR) {
-    if (lch=='[' && rch==']') return '|';
-    if (rch=='[' && lch==']') return '|';
-    if (lch=='{' && rch=='}') return '|';
-    if (rch=='{' && lch=='}') return '|';
-    if (lch=='(' && rch==')') return '|';
-    if (rch=='(' && lch==')') return '|';
-    }
+    if (lch == '[' && rch == ']')
+      return '|';
+    if (rch == '[' && lch == ']')
+      return '|';
+    if (lch == '{' && rch == '}')
+      return '|';
+    if (rch == '{' && lch == '}')
+      return '|';
+    if (lch == '(' && rch == ')')
+      return '|';
+    if (rch == '(' && lch == ')')
+      return '|';
+  }
 
   if (smushmode & SM_BIGX) {
-    if (lch=='/' && rch=='\\') return '|';
-    if (rch=='/' && lch=='\\') return 'Y';
-    if (lch=='>' && rch=='<') return 'X';
-      /* Don't want the reverse of above to give 'X'. */
-    }
+    if (lch == '/' && rch == '\\')
+      return '|';
+    if (rch == '/' && lch == '\\')
+      return 'Y';
+    if (lch == '>' && rch == '<')
+      return 'X';
+    /* Don't want the reverse of above to give 'X'. */
+  }
 
   return '\0';
 }
 
-
 /****************************************************************************
 
   smushamt
@@ -1443,48 +1469,50 @@ outchr lch,rch;
 
 ****************************************************************************/
 
-int smushamt()
-{
-  int maxsmush,amt;
-  int row,linebd,charbd;
-  outchr ch1,ch2;
+int smushamt() {
+  int maxsmush, amt;
+  int row, linebd, charbd;
+  outchr ch1, ch2;
 
   if ((smushmode & (SM_SMUSH | SM_KERN)) == 0) {
     return 0;
-    }
+  }
   maxsmush = currcharwidth;
-  for (row=0;row<charheight;row++) {
+  for (row = 0; row < charheight; row++) {
     if (right2left) {
-      if (maxsmush>STRLEN(outputline[row])) {
-        maxsmush=STRLEN(outputline[row]);
-        }
-      for (charbd=STRLEN(currchar[row]);
-        ch1=currchar[row][charbd],(charbd>0&&(!ch1||ch1==' '));charbd--) ;
-      for (linebd=0;ch2=outputline[row][linebd],ch2==' ';linebd++) ;
-      amt = linebd+currcharwidth-1-charbd;
+      if (maxsmush > STRLEN(outputline[row])) {
+        maxsmush = STRLEN(outputline[row]);
       }
-    else {
-      for (linebd=STRLEN(outputline[row]);
-        ch1 = outputline[row][linebd],(linebd>0&&(!ch1||ch1==' '));linebd--) ;
-      for (charbd=0;ch2=currchar[row][charbd],ch2==' ';charbd++) ;
-      amt = charbd+outlinelen-1-linebd;
-      }
-    if (!ch1||ch1==' ') {
+      for (charbd = STRLEN(currchar[row]);
+           ch1 = currchar[row][charbd], (charbd > 0 && (!ch1 || ch1 == ' '));
+           charbd--)
+        ;
+      for (linebd = 0; ch2 = outputline[row][linebd], ch2 == ' '; linebd++)
+        ;
+      amt = linebd + currcharwidth - 1 - charbd;
+    } else {
+      for (linebd = STRLEN(outputline[row]);
+           ch1 = outputline[row][linebd], (linebd > 0 && (!ch1 || ch1 == ' '));
+           linebd--)
+        ;
+      for (charbd = 0; ch2 = currchar[row][charbd], ch2 == ' '; charbd++)
+        ;
+      amt = charbd + outlinelen - 1 - linebd;
+    }
+    if (!ch1 || ch1 == ' ') {
       amt++;
-      }
-    else if (ch2) {
-      if (smushem(ch1,ch2)!='\0') {
+    } else if (ch2) {
+      if (smushem(ch1, ch2) != '\0') {
         amt++;
-        }
       }
-    if (amt<maxsmush) {
+    }
+    if (amt < maxsmush) {
       maxsmush = amt;
-      }
     }
+  }
   return maxsmush;
 }
 
-
 /****************************************************************************
 
   addchar
@@ -1497,46 +1525,44 @@ int smushamt()
 int addchar(c)
 inchr c;
 {
-  int smushamount,row,k,column;
+  int smushamount, row, k, column;
   outchr *templine;
 
   getletter(c);
   smushamount = smushamt();
-  if (outlinelen+currcharwidth-smushamount>outlinelenlimit
-      ||inchrlinelen+1>inchrlinelenlimit) {
+  if (outlinelen + currcharwidth - smushamount > outlinelenlimit ||
+      inchrlinelen + 1 > inchrlinelenlimit) {
     return 0;
-    }
+  }
 
-  templine = (outchr*)myalloc(sizeof(outchr)*(outlinelenlimit+1));
-  for (row=0;row<charheight;row++) {
+  templine = (outchr *)myalloc(sizeof(outchr) * (outlinelenlimit + 1));
+  for (row = 0; row < charheight; row++) {
     if (right2left) {
-      STRCPY(templine,currchar[row]);
-      for (k=0;k<smushamount;k++) {
-        templine[currcharwidth-smushamount+k] =
-          smushem(templine[currcharwidth-smushamount+k],outputline[row][k]);
-        }
-      STRCAT(templine,outputline[row]+smushamount);
-      STRCPY(outputline[row],templine);
+      STRCPY(templine, currchar[row]);
+      for (k = 0; k < smushamount; k++) {
+        templine[currcharwidth - smushamount + k] = smushem(
+            templine[currcharwidth - smushamount + k], outputline[row][k]);
       }
-    else {
-      for (k=0;k<smushamount;k++) {
-	column = outlinelen-smushamount+k;
-	if (column < 0) {
-	  column = 0;
-	  }
-        outputline[row][column] =
-          smushem(outputline[row][column],currchar[row][k]);
+      STRCAT(templine, outputline[row] + smushamount);
+      STRCPY(outputline[row], templine);
+    } else {
+      for (k = 0; k < smushamount; k++) {
+        column = outlinelen - smushamount + k;
+        if (column < 0) {
+          column = 0;
         }
-      STRCAT(outputline[row],currchar[row]+smushamount);
+        outputline[row][column] =
+            smushem(outputline[row][column], currchar[row][k]);
       }
+      STRCAT(outputline[row], currchar[row] + smushamount);
     }
+  }
   free(templine);
   outlinelen = STRLEN(outputline[0]);
   inchrline[inchrlinelen++] = c;
   return 1;
 }
 
-
 /****************************************************************************
 
   putstring
@@ -1550,10 +1576,9 @@ inchr c;
 
 ****************************************************************************/
 
-void putstring(string)
-outchr *string;
+void putstring(string) outchr *string;
 {
-  int i,len;
+  int i, len;
   char c[10];
 #ifdef TLF_FONTS
   size_t size;
@@ -1561,36 +1586,37 @@ outchr *string;
 #endif
 
   len = STRLEN(string);
-  if (outputwidth>1) {
-    if (len>outputwidth-1) {
-      len = outputwidth-1;
-      }
-    if (justification>0) {
-      for (i=1;(3-justification)*i+len+justification-2<outputwidth;i++) {
+  if (outputwidth > 1) {
+    if (len > outputwidth - 1) {
+      len = outputwidth - 1;
+    }
+    if (justification > 0) {
+      for (i = 1;
+           (3 - justification) * i + len + justification - 2 < outputwidth;
+           i++) {
         putchar(' ');
-        }
       }
     }
-  for (i=0;i<len;i++) {
+  }
+  for (i = 0; i < len; i++) {
 #ifdef TLF_FONTS
     wc[0] = string[i];
     wc[1] = 0;
-    size = wchar_to_utf8(wc,1,c,10,0);
-    if(size==1) {
-      if(c[0]==hardblank) {
+    size = wchar_to_utf8(wc, 1, c, 10, 0);
+    if (size == 1) {
+      if (c[0] == hardblank) {
         c[0] = ' ';
-        }
       }
+    }
     c[size] = 0;
-    printf("%s",c);
+    printf("%s", c);
 #else
-    putchar(string[i]==hardblank?' ':string[i]);
+    putchar(string[i] == hardblank ? ' ' : string[i]);
 #endif
-    }
+  }
   putchar('\n');
 }
 
-
 /****************************************************************************
 
   printline
@@ -1599,17 +1625,15 @@ outchr *string;
 
 ****************************************************************************/
 
-void printline()
-{
+void printline() {
   int i;
 
-  for (i=0;i<charheight;i++) {
+  for (i = 0; i < charheight; i++) {
     putstring(outputline[i]);
-    }
+  }
   clearline();
 }
 
-
 /****************************************************************************
 
   splitline
@@ -1620,45 +1644,43 @@ void printline()
 
 ****************************************************************************/
 
-void splitline()
-{
-  int i,gotspace,lastspace,len1,len2;
-  inchr *part1,*part2;
+void splitline() {
+  int i, gotspace, lastspace, len1, len2;
+  inchr *part1, *part2;
 
-  part1 = (inchr*)myalloc(sizeof(inchr)*(inchrlinelen+1));
-  part2 = (inchr*)myalloc(sizeof(inchr)*(inchrlinelen+1));
+  part1 = (inchr *)myalloc(sizeof(inchr) * (inchrlinelen + 1));
+  part2 = (inchr *)myalloc(sizeof(inchr) * (inchrlinelen + 1));
   gotspace = 0;
-  lastspace = inchrlinelen-1;
-  for (i=inchrlinelen-1;i>=0;i--) {
-    if (!gotspace && inchrline[i]==' ') {
+  lastspace = inchrlinelen - 1;
+  for (i = inchrlinelen - 1; i >= 0; i--) {
+    if (!gotspace && inchrline[i] == ' ') {
       gotspace = 1;
       lastspace = i;
-      }
-    if (gotspace && inchrline[i]!=' ') {
+    }
+    if (gotspace && inchrline[i] != ' ') {
       break;
-      }
     }
-  len1 = i+1;
-  len2 = inchrlinelen-lastspace-1;
-  for (i=0;i<len1;i++) {
+  }
+  len1 = i + 1;
+  len2 = inchrlinelen - lastspace - 1;
+  for (i = 0; i < len1; i++) {
     part1[i] = inchrline[i];
-    }
-  for (i=0;i<len2;i++) {
-    part2[i] = inchrline[lastspace+1+i];
-    }
+  }
+  for (i = 0; i < len2; i++) {
+    part2[i] = inchrline[lastspace + 1 + i];
+  }
   clearline();
-  for (i=0;i<len1;i++) {
+  for (i = 0; i < len1; i++) {
     addchar(part1[i]);
-    }
+  }
   printline();
-  for (i=0;i<len2;i++) {
+  for (i = 0; i < len2; i++) {
     addchar(part2[i]);
-    }
+  }
   free(part1);
   free(part2);
 }
 
-
 /****************************************************************************
 
   handlemapping
@@ -1673,19 +1695,17 @@ inchr c;
 {
   comnode *cmptr;
 
-  cmptr=commandlist;
-  while (cmptr!=NULL) {
-    if (cmptr->thecommand ?
-      (c >= cmptr->rangelo && c <= cmptr->rangehi) : 0) {
+  cmptr = commandlist;
+  while (cmptr != NULL) {
+    if (cmptr->thecommand ? (c >= cmptr->rangelo && c <= cmptr->rangehi) : 0) {
       c += cmptr->offset;
-      while(cmptr!=NULL ? cmptr->thecommand : 0) {
-        cmptr=cmptr->next;
-        }
-      }
-    else {
-      cmptr=cmptr->next;
+      while (cmptr != NULL ? cmptr->thecommand : 0) {
+        cmptr = cmptr->next;
       }
+    } else {
+      cmptr = cmptr->next;
     }
+  }
   return c;
 }
 
@@ -1699,40 +1719,38 @@ inchr c;
 
 ****************************************************************************/
 
-int Agetchar()
-{
-    extern int optind;		/* current argv[] element under study */
-    static int AgetMode = 0;	/* >= 0 for displacement into argv[n], <0 EOF */
-    char   *arg;		/* pointer to active character */
-    int    c;			/* current character */
-
-    if ( ! cmdinput )		/* is -A active? */
-	return( getchar() );	/* no: return stdin character */
-
-    if ( AgetMode < 0 || optind >= Myargc )		/* EOF is sticky: */
-	return( EOF );		/* **ensure it now and forever more */
-
-    /* find next character */
-    arg = Myargv[optind];		/* pointer to active arg */
-    c = arg[AgetMode++]&0xFF;	/* get appropriate char of arg */
-
-    if ( ! c )			/* at '\0' that terminates word? */
-    {   /* at end of word: return ' ' if normal word, '\n' if empty */
-	c = ' ';		/* suppose normal word and return blank */
-	if ( AgetMode == 1 )	/* if ran out in very 1st char, force \n */
-	    c = '\n';		/* (allows "hello '' world" to do \n at '') */
-	AgetMode = 0;		/* return to char 0 in NEXT word */
-	if ( ++optind >= Myargc )	/* run up word count and check if at "EOF" */
-	{   /* just ran out of arguments */
-	    c = EOF;		/* return EOF */
-	    AgetMode = -1;	/* ensure all future returns return EOF */
-	}
+int Agetchar() {
+  extern int optind;       /* current argv[] element under study */
+  static int AgetMode = 0; /* >= 0 for displacement into argv[n], <0 EOF */
+  char *arg;               /* pointer to active character */
+  int c;                   /* current character */
+
+  if (!cmdinput)        /* is -A active? */
+    return (getchar()); /* no: return stdin character */
+
+  if (AgetMode < 0 || optind >= Myargc) /* EOF is sticky: */
+    return (EOF);                       /* **ensure it now and forever more */
+
+  /* find next character */
+  arg = Myargv[optind];       /* pointer to active arg */
+  c = arg[AgetMode++] & 0xFF; /* get appropriate char of arg */
+
+  if (!c)    /* at '\0' that terminates word? */
+  {          /* at end of word: return ' ' if normal word, '\n' if empty */
+    c = ' '; /* suppose normal word and return blank */
+    if (AgetMode == 1)      /* if ran out in very 1st char, force \n */
+      c = '\n';             /* (allows "hello '' world" to do \n at '') */
+    AgetMode = 0;           /* return to char 0 in NEXT word */
+    if (++optind >= Myargc) /* run up word count and check if at "EOF" */
+    {                       /* just ran out of arguments */
+      c = EOF;              /* return EOF */
+      AgetMode = -1;        /* ensure all future returns return EOF */
     }
+  }
 
-    return( c );		/* return appropriate character */
-
-}	/* end: Agetchar() */
+  return (c); /* return appropriate character */
 
+} /* end: Agetchar() */
 
 /****************************************************************************
 
@@ -1742,137 +1760,151 @@ int Agetchar()
 
 ******************************************************************************/
 
-inchr iso2022()
-{
+inchr iso2022() {
   inchr ch;
   inchr ch2;
   int save_gl;
   int save_gr;
 
   ch = Agetchar();
-  if (ch == EOF) return ch;
-  if (ch == 27) ch = Agetchar() + 0x100; /* ESC x */
-  if (ch == 0x100 + '$') ch = Agetchar() + 0x200; /* ESC $ x */
+  if (ch == EOF)
+    return ch;
+  if (ch == 27)
+    ch = Agetchar() + 0x100; /* ESC x */
+  if (ch == 0x100 + '$')
+    ch = Agetchar() + 0x200; /* ESC $ x */
   switch (ch) {
-    case 14: /* invoke G1 into GL */
-      gl = 1;
-      return iso2022();
-    case 15: /* invoke G0 into GL */
-      gl = 0;
-      return iso2022();
-    case 142: case 'N' + 0x100: /* invoke G2 into GL for next char */
-      save_gl = gl; save_gr = gr;
-      gl = gr = 2;
-      ch = iso2022();
-      gl = save_gl; gr = save_gr;
-      return ch;
-    case 143: case 'O' + 0x100: /* invoke G3 into GL for next char */
-      save_gl = gl; save_gr = gr;
-      gl = gr = 3;
-      ch = iso2022();
-      gl = save_gl; gr = save_gr;
-      return ch;
-    case 'n' + 0x100: /* invoke G2 into GL */
-      gl = 2;
-      return iso2022();
-    case 'o' + 0x100: /* invoke G3 into GL */
-      gl = 3;
-      return iso2022();
-    case '~' + 0x100: /* invoke G1 into GR */
-      gr = 1;
-      return iso2022();
-    case '}' + 0x100: /* invoke G2 into GR */
-      gr = 2;
-      return iso2022();
-    case '|' + 0x100: /* invoke G3 into GR */
-      gr = 3;
-      return iso2022();
-    case '(' + 0x100: /* set G0 to 94-char set */
-      ch = Agetchar();
-      if (ch == 'B') ch = 0; /* ASCII */
-      gn[0] = ch << 16;
-      gndbl[0] = 0;
-      return iso2022();
-    case ')' + 0x100: /* set G1 to 94-char set */
-      ch = Agetchar();
-      if (ch == 'B') ch = 0;
-      gn[1] = ch << 16;
-      gndbl[1] = 0;
-      return iso2022();
-    case '*' + 0x100: /* set G2 to 94-char set */
-      ch = Agetchar();
-      if (ch == 'B') ch = 0;
-      gn[2] = ch << 16;
-      gndbl[2] = 0;
-      return iso2022();
-    case '+' + 0x100: /* set G3 to 94-char set */
-      ch = Agetchar();
-      if (ch == 'B') ch = 0;
-      gn[3] = ch << 16;
-      gndbl[3] = 0;
-      return iso2022();
-    case '-' + 0x100: /* set G1 to 96-char set */
-      ch = Agetchar();
-      if (ch == 'A') ch = 0; /* Latin-1 top half */
-      gn[1] = (ch << 16) | 0x80;
-      gndbl[1] = 0;
-      return iso2022();
-    case '.' + 0x100: /* set G2 to 96-char set */
-      ch = Agetchar();
-      if (ch == 'A') ch = 0;
-      gn[2] = (ch << 16) | 0x80;
-      gndbl[2] = 0;
-      return iso2022();
-    case '/' + 0x100: /* set G3 to 96-char set */
-      ch = Agetchar();
-      if (ch == 'A') ch = 0;
-      gn[3] = (ch << 16) | 0x80;
-      gndbl[3] = 0;
-      return iso2022();
-    case '(' + 0x200: /* set G0 to 94 x 94 char set */
-      ch = Agetchar();
-      gn[0] = ch << 16;
+  case 14: /* invoke G1 into GL */
+    gl = 1;
+    return iso2022();
+  case 15: /* invoke G0 into GL */
+    gl = 0;
+    return iso2022();
+  case 142:
+  case 'N' + 0x100: /* invoke G2 into GL for next char */
+    save_gl = gl;
+    save_gr = gr;
+    gl = gr = 2;
+    ch = iso2022();
+    gl = save_gl;
+    gr = save_gr;
+    return ch;
+  case 143:
+  case 'O' + 0x100: /* invoke G3 into GL for next char */
+    save_gl = gl;
+    save_gr = gr;
+    gl = gr = 3;
+    ch = iso2022();
+    gl = save_gl;
+    gr = save_gr;
+    return ch;
+  case 'n' + 0x100: /* invoke G2 into GL */
+    gl = 2;
+    return iso2022();
+  case 'o' + 0x100: /* invoke G3 into GL */
+    gl = 3;
+    return iso2022();
+  case '~' + 0x100: /* invoke G1 into GR */
+    gr = 1;
+    return iso2022();
+  case '}' + 0x100: /* invoke G2 into GR */
+    gr = 2;
+    return iso2022();
+  case '|' + 0x100: /* invoke G3 into GR */
+    gr = 3;
+    return iso2022();
+  case '(' + 0x100: /* set G0 to 94-char set */
+    ch = Agetchar();
+    if (ch == 'B')
+      ch = 0; /* ASCII */
+    gn[0] = ch << 16;
+    gndbl[0] = 0;
+    return iso2022();
+  case ')' + 0x100: /* set G1 to 94-char set */
+    ch = Agetchar();
+    if (ch == 'B')
+      ch = 0;
+    gn[1] = ch << 16;
+    gndbl[1] = 0;
+    return iso2022();
+  case '*' + 0x100: /* set G2 to 94-char set */
+    ch = Agetchar();
+    if (ch == 'B')
+      ch = 0;
+    gn[2] = ch << 16;
+    gndbl[2] = 0;
+    return iso2022();
+  case '+' + 0x100: /* set G3 to 94-char set */
+    ch = Agetchar();
+    if (ch == 'B')
+      ch = 0;
+    gn[3] = ch << 16;
+    gndbl[3] = 0;
+    return iso2022();
+  case '-' + 0x100: /* set G1 to 96-char set */
+    ch = Agetchar();
+    if (ch == 'A')
+      ch = 0; /* Latin-1 top half */
+    gn[1] = (ch << 16) | 0x80;
+    gndbl[1] = 0;
+    return iso2022();
+  case '.' + 0x100: /* set G2 to 96-char set */
+    ch = Agetchar();
+    if (ch == 'A')
+      ch = 0;
+    gn[2] = (ch << 16) | 0x80;
+    gndbl[2] = 0;
+    return iso2022();
+  case '/' + 0x100: /* set G3 to 96-char set */
+    ch = Agetchar();
+    if (ch == 'A')
+      ch = 0;
+    gn[3] = (ch << 16) | 0x80;
+    gndbl[3] = 0;
+    return iso2022();
+  case '(' + 0x200: /* set G0 to 94 x 94 char set */
+    ch = Agetchar();
+    gn[0] = ch << 16;
+    gndbl[0] = 1;
+    return iso2022();
+  case ')' + 0x200: /* set G1 to 94 x 94 char set */
+    ch = Agetchar();
+    gn[1] = ch << 16;
+    gndbl[1] = 1;
+    return iso2022();
+  case '*' + 0x200: /* set G2 to 94 x 94 char set */
+    ch = Agetchar();
+    gn[2] = ch << 16;
+    gndbl[2] = 1;
+    return iso2022();
+  case '+' + 0x200: /* set G3 to 94 x 94 char set */
+    ch = Agetchar();
+    gn[3] = ch << 16;
+    gndbl[3] = 1;
+    return iso2022();
+  default:
+    if (ch & 0x200) { /* set G0 to 94 x 94 char set (deprecated) */
+      gn[0] = (ch & ~0x200) << 16;
       gndbl[0] = 1;
       return iso2022();
-    case ')' + 0x200: /* set G1 to 94 x 94 char set */
-      ch = Agetchar();
-      gn[1] = ch << 16;
-      gndbl[1] = 1;
-      return iso2022();
-    case '*' + 0x200: /* set G2 to 94 x 94 char set */
-      ch = Agetchar();
-      gn[2] = ch << 16;
-      gndbl[2] = 1;
-      return iso2022();
-    case '+' + 0x200: /* set G3 to 94 x 94 char set */
-      ch = Agetchar();
-      gn[3] = ch << 16;
-      gndbl[3] = 1;
-      return iso2022();
-    default:
-      if (ch & 0x200) { /* set G0 to 94 x 94 char set (deprecated) */
-        gn[0] = (ch & ~0x200) << 16;
-        gndbl[0] = 1;
-        return iso2022();
-        }
-      }
+    }
+  }
 
   if (ch >= 0x21 && ch <= 0x7E) { /* process GL */
     if (gndbl[gl]) {
       ch2 = Agetchar();
       return gn[gl] | (ch << 8) | ch2;
-      }
-    else return gn[gl] | ch;
-    }
-  else if (ch >= 0xA0 && ch <= 0xFF) { /* process GR */
+    } else
+      return gn[gl] | ch;
+  } else if (ch >= 0xA0 && ch <= 0xFF) { /* process GR */
     if (gndbl[gr]) {
       ch2 = Agetchar();
       return gn[gr] | (ch << 8) | ch2;
-      }
-    else return gn[gr] | (ch & ~0x80);
-    }
-  else return ch;
-  }
+    } else
+      return gn[gr] | (ch & ~0x80);
+  } else
+    return ch;
+}
 
 /****************************************************************************
 
@@ -1909,85 +1941,81 @@ inchr c;
     "~~" is a tilde, "~x" for all other x is ignored).
   If multibyte = 4, Shift-JIS mode (0x80-0x9F and 0xE0-0xEF are first byte
     of a double-byte character, all other bytes are characters).
- 
+
 
 *****************************************************************************/
 
-inchr getinchr()
-{
+inchr getinchr() {
   int ch, ch2, ch3, ch4, ch5, ch6;
 
   if (getinchr_flag) {
     getinchr_flag = 0;
     return getinchr_buffer;
-    }
+  }
 
-  switch(multibyte) {
-   case 0: /* single-byte */
-      return iso2022();
-   case 1: /* DBCS */
-     ch = Agetchar();
-     if ((ch >= 0x80 && ch <= 0x9F) ||
-         (ch >= 0xE0 && ch <= 0xEF)) {
-       ch = (ch << 8) + Agetchar();
-       }
-     return ch;
-   case 2: /* UTF-8 */
+  switch (multibyte) {
+  case 0: /* single-byte */
+    return iso2022();
+  case 1: /* DBCS */
+    ch = Agetchar();
+    if ((ch >= 0x80 && ch <= 0x9F) || (ch >= 0xE0 && ch <= 0xEF)) {
+      ch = (ch << 8) + Agetchar();
+    }
+    return ch;
+  case 2: /* UTF-8 */
+    ch = Agetchar();
+    if (ch < 0x80)
+      return ch; /* handles EOF, too */
+    if (ch < 0xC0 || ch > 0xFD)
+      return 0x0080; /* illegal first character */
+    ch2 = Agetchar() & 0x3F;
+    if (ch < 0xE0)
+      return ((ch & 0x1F) << 6) + ch2;
+    ch3 = Agetchar() & 0x3F;
+    if (ch < 0xF0)
+      return ((ch & 0x0F) << 12) + (ch2 << 6) + ch3;
+    ch4 = Agetchar() & 0x3F;
+    if (ch < 0xF8)
+      return ((ch & 0x07) << 18) + (ch2 << 12) + (ch3 << 6) + ch4;
+    ch5 = Agetchar() & 0x3F;
+    if (ch < 0xFC)
+      return ((ch & 0x03) << 24) + (ch2 << 18) + (ch3 << 12) + (ch4 << 6) + ch5;
+    ch6 = Agetchar() & 0x3F;
+    return ((ch & 0x01) << 30) + (ch2 << 24) + (ch3 << 18) + (ch4 << 12) +
+           (ch5 << 6) + ch6;
+  case 3: /* HZ */
+    ch = Agetchar();
+    if (ch == EOF)
+      return ch;
+    if (hzmode) {
+      ch = (ch << 8) + Agetchar();
+      if (ch == ('}' << 8) + '~') {
+        hzmode = 0;
+        return getinchr();
+      }
+      return ch;
+    } else if (ch == '~') {
       ch = Agetchar();
-      if (ch < 0x80) return ch;  /* handles EOF, too */
-      if (ch < 0xC0 || ch > 0xFD)
-        return 0x0080;  /* illegal first character */
-      ch2 = Agetchar() & 0x3F;
-      if (ch < 0xE0) return ((ch & 0x1F) << 6) + ch2;
-      ch3 = Agetchar() & 0x3F;
-      if (ch < 0xF0)
-        return ((ch & 0x0F) << 12) + (ch2 << 6) + ch3;
-      ch4 = Agetchar() & 0x3F;
-      if (ch < 0xF8)
-        return ((ch & 0x07) << 18) + (ch2 << 12) + (ch3 << 6) + ch4;
-      ch5 = Agetchar() & 0x3F;
-      if (ch < 0xFC)
-        return ((ch & 0x03) << 24) + (ch2 << 18) + (ch3 << 12) +
-          (ch4 << 6) + ch5;
-      ch6 = Agetchar() & 0x3F;
-      return ((ch & 0x01) << 30) + (ch2 << 24) + (ch3 << 18) +
-        (ch4 << 12) + (ch5 << 6) + ch6;
-   case 3: /* HZ */
-     ch = Agetchar();
-     if (ch == EOF) return ch;
-     if (hzmode) {
-       ch = (ch << 8) + Agetchar();
-       if (ch == ('}' << 8) + '~') {
-         hzmode = 0;
-         return getinchr();
-         }
-       return ch;
-       }
-     else if (ch == '~') {
-       ch = Agetchar();
-       if (ch == '{') {
-          hzmode = 1;
-          return getinchr();
-          }
-      else if (ch == '~') {
+      if (ch == '{') {
+        hzmode = 1;
+        return getinchr();
+      } else if (ch == '~') {
         return ch;
-        }
-      else {
+      } else {
         return getinchr();
-        }
       }
-     else return ch;
-   case 4: /* Shift-JIS */
-     ch = Agetchar();
-     if ((ch >= 0x80 && ch <= 0x9F) ||
-         (ch >= 0xE0 && ch <= 0xEF)) {
-       ch = (ch << 8) + Agetchar();
-       }
-     return ch;
-   default:
-     return 0x80;
-    }
+    } else
+      return ch;
+  case 4: /* Shift-JIS */
+    ch = Agetchar();
+    if ((ch >= 0x80 && ch <= 0x9F) || (ch >= 0xE0 && ch <= 0xEF)) {
+      ch = (ch << 8) + Agetchar();
+    }
+    return ch;
+  default:
+    return 0x80;
   }
+}
 
 /****************************************************************************
 
@@ -2000,22 +2028,22 @@ inchr getinchr()
 
 ****************************************************************************/
 
-int main(argc,argv)
+int main(argc, argv)
 int argc;
 char *argv[];
 {
-  inchr c,c2;
+  inchr c, c2;
   int i;
   int last_was_eol_flag;
-/*---------------------------------------------------------------------------
-  wordbreakmode:
-    -1: /^$/ and blanks are to be absorbed (when line break was forced
-      by a blank or character larger than outlinelenlimit)
-    0: /^ *$/ and blanks are not to be absorbed
-    1: /[^ ]$/ no word break yet
-    2: /[^ ]  *$/
-    3: /[^ ]$/ had a word break
----------------------------------------------------------------------------*/
+  /*---------------------------------------------------------------------------
+    wordbreakmode:
+      -1: /^$/ and blanks are to be absorbed (when line break was forced
+        by a blank or character larger than outlinelenlimit)
+      0: /^ *$/ and blanks are not to be absorbed
+      1: /[^ ]$/ no word break yet
+      2: /[^ ]  *$/
+      3: /[^ ]$/ had a word break
+  ---------------------------------------------------------------------------*/
   int wordbreakmode;
   int char_not_added;
 
@@ -2033,102 +2061,97 @@ char *argv[];
   toiletfont = 0;
 #endif
 
-  while ((c = getinchr())!=EOF) {
+  while ((c = getinchr()) != EOF) {
 
-    if (c=='\n'&&paragraphflag&&!last_was_eol_flag) {
+    if (c == '\n' && paragraphflag && !last_was_eol_flag) {
       ungetinchr(c2 = getinchr());
-      c = ((isascii(c2)&&isspace(c2))?'\n':' ');
-      }
-    last_was_eol_flag = (isascii(c)&&isspace(c)&&c!='\t'&&c!=' ');
+      c = ((isascii(c2) && isspace(c2)) ? '\n' : ' ');
+    }
+    last_was_eol_flag = (isascii(c) && isspace(c) && c != '\t' && c != ' ');
 
     if (deutschflag) {
-      if (c>='[' && c<=']') {
-        c = deutsch[c-'['];
-        }
-      else if (c >='{' && c <= '~') {
-        c = deutsch[c-'{'+3];
-        }
+      if (c >= '[' && c <= ']') {
+        c = deutsch[c - '['];
+      } else if (c >= '{' && c <= '~') {
+        c = deutsch[c - '{' + 3];
       }
+    }
 
     c = handlemapping(c);
 
-    if (isascii(c)&&isspace(c)) {
-      c = (c=='\t'||c==' ') ? ' ' : '\n';
-      }
+    if (isascii(c) && isspace(c)) {
+      c = (c == '\t' || c == ' ') ? ' ' : '\n';
+    }
 
-    if ((c>'\0' && c<' ' && c!='\n') || c==127) continue;
+    if ((c > '\0' && c < ' ' && c != '\n') || c == 127)
+      continue;
 
-/*
-  Note: The following code is complex and thoroughly tested.
-  Be careful when modifying!
-*/
+    /*
+      Note: The following code is complex and thoroughly tested.
+      Be careful when modifying!
+    */
 
     do {
       char_not_added = 0;
 
-      if (wordbreakmode== -1) {
-        if (c==' ') {
+      if (wordbreakmode == -1) {
+        if (c == ' ') {
           break;
-          }
-        else if (c=='\n') {
+        } else if (c == '\n') {
           wordbreakmode = 0;
           break;
-          }
-        wordbreakmode = 0;
         }
+        wordbreakmode = 0;
+      }
 
-      if (c=='\n') {
+      if (c == '\n') {
         printline();
         wordbreakmode = 0;
-        }
+      }
 
       else if (addchar(c)) {
-        if (c!=' ') {
-          wordbreakmode = (wordbreakmode>=2)?3:1;
-          }
-        else {
-          wordbreakmode = (wordbreakmode>0)?2:0;
-          }
+        if (c != ' ') {
+          wordbreakmode = (wordbreakmode >= 2) ? 3 : 1;
+        } else {
+          wordbreakmode = (wordbreakmode > 0) ? 2 : 0;
         }
+      }
 
-      else if (outlinelen==0) {
-        for (i=0;i<charheight;i++) {
-          if (right2left && outputwidth>1) {
-            putstring(currchar[i]+STRLEN(currchar[i])-outlinelenlimit);
-            }
-          else {
+      else if (outlinelen == 0) {
+        for (i = 0; i < charheight; i++) {
+          if (right2left && outputwidth > 1) {
+            putstring(currchar[i] + STRLEN(currchar[i]) - outlinelenlimit);
+          } else {
             putstring(currchar[i]);
-            }
           }
-        wordbreakmode = -1;
         }
+        wordbreakmode = -1;
+      }
 
-      else if (c==' ') {
-        if (wordbreakmode==2) {
+      else if (c == ' ') {
+        if (wordbreakmode == 2) {
           splitline();
-          }
-        else {
+        } else {
           printline();
-          }
-        wordbreakmode = -1;
         }
+        wordbreakmode = -1;
+      }
 
       else {
-        if (wordbreakmode>=2) {
+        if (wordbreakmode >= 2) {
           splitline();
-          }
-        else {
+        } else {
           printline();
-          }
-        wordbreakmode = (wordbreakmode==3)?1:0;
-        char_not_added = 1;
         }
+        wordbreakmode = (wordbreakmode == 3) ? 1 : 0;
+        char_not_added = 1;
+      }
 
-      } while (char_not_added);
-    }
+    } while (char_not_added);
+  }
 
-  if (outlinelen!=0) {
+  if (outlinelen != 0) {
     printline();
-    }
+  }
   return 0;
 }
-- 
2.34.1

