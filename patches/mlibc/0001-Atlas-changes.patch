From af747e7c2cd13623da4cd2119026ab713010dcc1 Mon Sep 17 00:00:00 2001
From: Stoozy <stoozy@proton.me>
Date: Mon, 8 Aug 2022 20:12:55 -0400
Subject: [PATCH] Atlas changes

---
 meson.build                                  |   7 +-
 sysdeps/atlas/crt-x86_64/crt0.S              |   7 +
 sysdeps/atlas/generic/entry.cpp              |  34 +
 sysdeps/atlas/generic/generic.cpp            | 805 +++++++++++++++++++
 sysdeps/atlas/generic/thread.cpp             |  44 +
 sysdeps/atlas/generic/thread_entry.S         |   9 +
 sysdeps/atlas/include/abi-bits/access.h      |   1 +
 sysdeps/atlas/include/abi-bits/auxv.h        |   1 +
 sysdeps/atlas/include/abi-bits/blkcnt_t.h    |   1 +
 sysdeps/atlas/include/abi-bits/blksize_t.h   |   1 +
 sysdeps/atlas/include/abi-bits/clockid_t.h   |   1 +
 sysdeps/atlas/include/abi-bits/dev_t.h       |   1 +
 sysdeps/atlas/include/abi-bits/epoll.h       |   1 +
 sysdeps/atlas/include/abi-bits/errno.h       |   1 +
 sysdeps/atlas/include/abi-bits/fcntl.h       |   1 +
 sysdeps/atlas/include/abi-bits/gid_t.h       |   1 +
 sysdeps/atlas/include/abi-bits/in.h          |   1 +
 sysdeps/atlas/include/abi-bits/ino_t.h       |   1 +
 sysdeps/atlas/include/abi-bits/inotify.h     |   1 +
 sysdeps/atlas/include/abi-bits/limits.h      |   1 +
 sysdeps/atlas/include/abi-bits/mode_t.h      |   1 +
 sysdeps/atlas/include/abi-bits/nlink_t.h     |   1 +
 sysdeps/atlas/include/abi-bits/packet.h      |   1 +
 sysdeps/atlas/include/abi-bits/pid_t.h       |   1 +
 sysdeps/atlas/include/abi-bits/poll.h        |   1 +
 sysdeps/atlas/include/abi-bits/ptrace.h      |   1 +
 sysdeps/atlas/include/abi-bits/reboot.h      |   1 +
 sysdeps/atlas/include/abi-bits/resource.h    |   1 +
 sysdeps/atlas/include/abi-bits/seek-whence.h |   1 +
 sysdeps/atlas/include/abi-bits/shm.h         |   1 +
 sysdeps/atlas/include/abi-bits/signal.h      |   1 +
 sysdeps/atlas/include/abi-bits/socket.h      |   1 +
 sysdeps/atlas/include/abi-bits/stat.h        |   1 +
 sysdeps/atlas/include/abi-bits/termios.h     |   1 +
 sysdeps/atlas/include/abi-bits/time.h        |   1 +
 sysdeps/atlas/include/abi-bits/uid_t.h       |   1 +
 sysdeps/atlas/include/abi-bits/utsname.h     |   1 +
 sysdeps/atlas/include/abi-bits/vm-flags.h    |   1 +
 sysdeps/atlas/include/abi-bits/vt.h          |   1 +
 sysdeps/atlas/include/abi-bits/wait.h        |   1 +
 sysdeps/atlas/include/mlibc/thread-entry.hpp |  10 +
 sysdeps/atlas/include/vfs.h                  |  28 +
 sysdeps/atlas/meson.build                    |  58 ++
 43 files changed, 1035 insertions(+), 1 deletion(-)
 create mode 100644 sysdeps/atlas/crt-x86_64/crt0.S
 create mode 100644 sysdeps/atlas/generic/entry.cpp
 create mode 100644 sysdeps/atlas/generic/generic.cpp
 create mode 100644 sysdeps/atlas/generic/thread.cpp
 create mode 100644 sysdeps/atlas/generic/thread_entry.S
 create mode 120000 sysdeps/atlas/include/abi-bits/access.h
 create mode 120000 sysdeps/atlas/include/abi-bits/auxv.h
 create mode 120000 sysdeps/atlas/include/abi-bits/blkcnt_t.h
 create mode 120000 sysdeps/atlas/include/abi-bits/blksize_t.h
 create mode 120000 sysdeps/atlas/include/abi-bits/clockid_t.h
 create mode 120000 sysdeps/atlas/include/abi-bits/dev_t.h
 create mode 120000 sysdeps/atlas/include/abi-bits/epoll.h
 create mode 120000 sysdeps/atlas/include/abi-bits/errno.h
 create mode 120000 sysdeps/atlas/include/abi-bits/fcntl.h
 create mode 120000 sysdeps/atlas/include/abi-bits/gid_t.h
 create mode 120000 sysdeps/atlas/include/abi-bits/in.h
 create mode 120000 sysdeps/atlas/include/abi-bits/ino_t.h
 create mode 120000 sysdeps/atlas/include/abi-bits/inotify.h
 create mode 120000 sysdeps/atlas/include/abi-bits/limits.h
 create mode 120000 sysdeps/atlas/include/abi-bits/mode_t.h
 create mode 120000 sysdeps/atlas/include/abi-bits/nlink_t.h
 create mode 120000 sysdeps/atlas/include/abi-bits/packet.h
 create mode 120000 sysdeps/atlas/include/abi-bits/pid_t.h
 create mode 120000 sysdeps/atlas/include/abi-bits/poll.h
 create mode 120000 sysdeps/atlas/include/abi-bits/ptrace.h
 create mode 120000 sysdeps/atlas/include/abi-bits/reboot.h
 create mode 120000 sysdeps/atlas/include/abi-bits/resource.h
 create mode 120000 sysdeps/atlas/include/abi-bits/seek-whence.h
 create mode 120000 sysdeps/atlas/include/abi-bits/shm.h
 create mode 120000 sysdeps/atlas/include/abi-bits/signal.h
 create mode 120000 sysdeps/atlas/include/abi-bits/socket.h
 create mode 120000 sysdeps/atlas/include/abi-bits/stat.h
 create mode 120000 sysdeps/atlas/include/abi-bits/termios.h
 create mode 120000 sysdeps/atlas/include/abi-bits/time.h
 create mode 120000 sysdeps/atlas/include/abi-bits/uid_t.h
 create mode 120000 sysdeps/atlas/include/abi-bits/utsname.h
 create mode 120000 sysdeps/atlas/include/abi-bits/vm-flags.h
 create mode 120000 sysdeps/atlas/include/abi-bits/vt.h
 create mode 120000 sysdeps/atlas/include/abi-bits/wait.h
 create mode 100644 sysdeps/atlas/include/mlibc/thread-entry.hpp
 create mode 100644 sysdeps/atlas/include/vfs.h
 create mode 100644 sysdeps/atlas/meson.build

diff --git a/meson.build b/meson.build
index 4c4668f0..1092f623 100644
--- a/meson.build
+++ b/meson.build
@@ -135,6 +135,11 @@ elif host_machine.system() == 'dripos'
 	rtdl_include_dirs += include_directories('sysdeps/dripos/include')
 	libc_include_dirs += include_directories('sysdeps/dripos/include')
 	subdir('sysdeps/dripos')
+elif host_machine.system() == 'atlas'
+	rtdl_include_dirs += include_directories('sysdeps/atlas/include')
+	libc_include_dirs += include_directories('sysdeps/atlas/include')
+	subdir('sysdeps/atlas')
+
 else
 	error('No sysdeps defined for OS: ' + host_machine.system())
 endif
@@ -306,7 +311,7 @@ if not headers_only
 
 	ld_cpp_args = [
 		'-fvisibility=hidden',
-		'-fno-stack-protector',
+        '-fno-stack-protector',
 		'-DMLIBC_BUILDING_RTDL'
 	]
 
diff --git a/sysdeps/atlas/crt-x86_64/crt0.S b/sysdeps/atlas/crt-x86_64/crt0.S
new file mode 100644
index 00000000..0a0a4a0c
--- /dev/null
+++ b/sysdeps/atlas/crt-x86_64/crt0.S
@@ -0,0 +1,7 @@
+
+.section .text
+.global _start
+_start:
+    mov $main, %rdi
+    call __mlibc_entry
+
diff --git a/sysdeps/atlas/generic/entry.cpp b/sysdeps/atlas/generic/entry.cpp
new file mode 100644
index 00000000..ee7a794b
--- /dev/null
+++ b/sysdeps/atlas/generic/entry.cpp
@@ -0,0 +1,34 @@
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <bits/ensure.h>
+#include <mlibc/elf/startup.h>
+
+// defined by the POSIX library
+void __mlibc_initLocale();
+
+extern "C" uintptr_t *__dlapi_entrystack();
+
+extern char **environ;
+static mlibc::exec_stack_data __mlibc_stack_data;
+
+struct LibraryGuard {
+	LibraryGuard();
+};
+
+static LibraryGuard guard;
+
+LibraryGuard::LibraryGuard() {
+	__mlibc_initLocale();
+
+	// Parse the exec() stack.
+	mlibc::parse_exec_stack(__dlapi_entrystack(), &__mlibc_stack_data);
+	mlibc::set_startup_data(__mlibc_stack_data.argc, __mlibc_stack_data.argv,
+			__mlibc_stack_data.envp);
+}
+
+extern "C" void __mlibc_entry(int (*main_fn)(int argc, char *argv[], char *env[])) {
+	auto result = main_fn(__mlibc_stack_data.argc, __mlibc_stack_data.argv, environ);
+	exit(result);
+}
+
diff --git a/sysdeps/atlas/generic/generic.cpp b/sysdeps/atlas/generic/generic.cpp
new file mode 100644
index 00000000..32b7e406
--- /dev/null
+++ b/sysdeps/atlas/generic/generic.cpp
@@ -0,0 +1,805 @@
+#include <bits/ensure.h>
+#include <dirent.h>
+#include <errno.h> 
+#include <limits.h>
+#include <mlibc/all-sysdeps.hpp>
+#include <mlibc/debug.hpp>
+#include <mlibc/thread-entry.hpp>
+#include <sys/types.h>
+#include <unistd.h>
+#include <vfs.h>
+#include <string.h>
+#include <abi-bits/vt.h>
+#include <linux/fb.h>
+
+//struct fb_var_screeninfo {
+//	unsigned long xres;			
+//	unsigned long yres;
+//	unsigned long xres_virtual;		
+//	unsigned long yres_virtual;
+//	unsigned long xoffset;			
+//	unsigned long yoffset;			
+//
+//	unsigned long bits_per_pixel;	
+//	unsigned long grayscale;	
+//
+//	int red : 4;		
+//	int green : 4;
+//	int blue : 4;
+//	int transp: 4;
+//
+//	unsigned long nonstd;			
+//
+//	unsigned long activate;		
+//
+//	unsigned long height;	
+//	unsigned long width;
+//
+//	unsigned long accel_flags;
+//	unsigned long pixclock;	
+//	unsigned long left_margin;
+//	unsigned long right_margin;
+//	unsigned long upper_margin;	
+//	unsigned long lower_margin;
+//	unsigned long hsync_len;
+//	unsigned long vsync_len;
+//	unsigned long sync;	
+//	unsigned long vmode;			
+//	unsigned long rotate;		
+//	unsigned long colorspace;	
+//	unsigned long reserved[4];
+//} __attribute__((packed));
+
+#define TIOCSPTLCK 1074025521
+#define TIOCGPTN 2147767344
+#define TIOCSWINSZ 21524
+#define TIOCSCTTY 21518
+#define FBIOGETCMAP 17924
+#define FBIOPUTCMAP 17925
+#define FBIOGET_VSCREENINFO 17920
+#define FBIOGET_FSCREENINFO 17922
+
+
+#define SYS_EXIT 0
+#define SYS_OPEN 1
+#define SYS_CLOSE 2
+#define SYS_READ 3
+#define SYS_WRITE 4
+#define SYS_LOG_LIBC 5
+#define SYS_VM_MAP 6
+#define SYS_SEEK 7
+#define SYS_TCB_SET 8
+#define SYS_IOCTL 9
+#define SYS_FORK 10
+#define SYS_WAIT 11
+#define SYS_STAT 12
+#define SYS_FSTAT 13
+#define SYS_GETPID 14
+#define SYS_DUP 15
+#define SYS_DUP2 16
+#define SYS_READDIR 17
+
+#define SYSCALL_NA0(call)                                                      \
+  ({                                                                           \
+    register uint64_t syscall asm("rsi") = call;                               \
+    asm volatile("syscall"                                                     \
+                 : "=r"(ret)                                                   \
+                 : "r"(syscall)                                                \
+                 : "rcx", "r11", "memory");                                    \
+  });
+
+#define SYSCALL_NA1(call, arg0)                                                \
+  ({                                                                           \
+    register uint64_t syscall asm("rsi") = call;                               \
+    register auto r8 asm("r8") = (arg0);                                       \
+    asm volatile("syscall"                                                     \
+                 : "=r"(ret)                                                   \
+                 : "r"(syscall), "r"(r8)                                       \
+                 : "rcx", "r11", "memory");                                    \
+  });
+
+#define SYSCALL_NA2(call, arg0, arg1)                                          \
+  ({                                                                           \
+    register uint64_t syscall asm("rsi") = call;                               \
+    register auto r8 asm("r8") = (arg0);                                       \
+    register auto r9 asm("r9") = (arg1);                                       \
+    asm volatile("syscall"                                                     \
+                 : "=r"(ret)                                                   \
+                 : "r"(syscall), "r"(r8), "r"(r9)                              \
+                 : "rcx", "r11", "memory");                                    \
+  });
+
+#define SYSCALL_NA3(call, arg0, arg1, arg2)                                    \
+  ({                                                                           \
+    register uint64_t syscall asm("rsi") = call;                               \
+    register auto r8 asm("r8") = (arg0);                                       \
+    register auto r9 asm("r9") = (arg1);                                       \
+    register auto r10 asm("r10") = (arg2);                                     \
+    asm volatile("syscall"                                                     \
+                 : "=r"(ret)                                                   \
+                 : "r"(syscall), "r"(r8), "r"(r9), "r"(r10)                    \
+                 : "rcx", "r11", "memory");                                    \
+  });
+
+#define SYSCALL_NA4(call, arg0, arg1, arg2, arg3)                              \
+  ({                                                                           \
+    register uint64_t syscall asm("rsi") = call;                               \
+    register auto r8 asm("r8") = (arg0);                                       \
+    register auto r9 asm("r9") = (arg1);                                       \
+    register auto r10 asm("r10") = (arg2);                                     \
+    register auto r12 asm("r12") = (arg3);                                     \
+    asm volatile("syscall"                                                     \
+                 : "=r"(ret)                                                   \
+                 : "r"(syscall), "r"(r8), "r"(r9), "r"(r10), "r"(r12)          \
+                 : "rcx", "r11", "memory");                                    \
+  });
+
+#define SYSCALL_NA5(call, arg0, arg1, arg2, arg3, arg4)                        \
+  ({                                                                           \
+    register uint64_t syscall asm("rsi") = call;                               \
+    register auto r8 asm("r8") = (arg0);                                       \
+    register auto r9 asm("r9") = (arg1);                                       \
+    register auto r10 asm("r10") = (arg2);                                     \
+    register auto r12 asm("r12") = (arg3);                                     \
+    register auto r13 asm("r13") = (arg4);                                     \
+    asm volatile("syscall"                                                     \
+                 : "=r"(ret)                                                   \
+                 : "r"(syscall), "r"(r8), "r"(r9), "r"(r10), "r"(r12),         \
+                   "r"(r13),                                                   \
+                 : "rcx", "r11", "memory");                                    \
+  });
+
+#define SYSCALL_NA6(call, arg0, arg1, arg2, arg3, arg4, arg5)                  \
+  ({                                                                           \
+    register uint64_t syscall asm("rsi") = call;                               \
+    register auto r8 asm("r8") = (arg0);                                       \
+    register auto r9 asm("r9") = (arg1);                                       \
+    register auto r10 asm("r10") = (arg2);                                     \
+    register auto r12 asm("r12") = (arg3);                                     \
+    register auto r13 asm("r13") = (arg4);                                     \
+    register auto r14 asm("r14") = (arg5);                                     \
+    asm volatile("syscall"                                                     \
+                 : "=r"(ret)                                                   \
+                 : "r"(syscall), "r"(r8), "r"(r9), "r"(r10), "r"(r12),         \
+                   "r"(r13), "r"(r14)                                          \
+                 : "rcx", "r11", "memory");                                    \
+  });
+
+namespace mlibc {
+
+void sys_libc_log(const char *message) {
+  register int ret asm("r15");
+  SYSCALL_NA1(SYS_LOG_LIBC, message);
+
+  return;
+}
+
+void sys_libc_panic() {
+  mlibc::infoLogger() << "\e[31mmlibc: panic!" << frg::endlog;
+  for (;;)
+    ;
+}
+
+int sys_tcb_set(void *pointer) {
+  register int ret asm("r15");
+  SYSCALL_NA1(SYS_TCB_SET, pointer);
+
+  int r = ret;
+  mlibc::infoLogger() << "Got tcb_set return " << r << frg::endlog;
+  return ret;
+}
+
+int sys_anon_allocate(size_t size, void **pointer) {
+
+  int errno = sys_vm_map(NULL, size, PROT_EXEC | PROT_READ | PROT_WRITE,
+                         MAP_ANONYMOUS, -1, 0, pointer);
+
+  return errno;
+}
+
+int sys_anon_free(void *pointer, size_t size) {
+  // TODO
+  return 0;
+}
+
+#ifndef MLIBC_BUILDING_RTDL
+void sys_exit(int status) {
+  register int ret asm("r15");
+  SYSCALL_NA1(SYS_EXIT, status);
+}
+#endif
+
+#ifndef MLIBC_BUILDING_RTDL
+int sys_clock_get(int clock, time_t *secs, long *nanos) { 
+
+    mlibc::infoLogger() << "[mlibc] Calling sys_clock_get() STUB\n" << frg::endlog;
+    return 0; 
+}
+#endif
+
+int sys_open(const char *path, int flags, unsigned int mode, int *fd) {
+  mlibc::infoLogger() << "[mlibc] Called sys_open on " << path << frg::endlog;
+  mlibc::infoLogger() << "[mlibc] path len is " << strlen(path) <<frg::endlog;
+  //if(path[0] == '\0' ||  path == NULL || strlen(path) == 0 || strlen(path) == 1)
+      //return EINVAL;
+
+  register int ret asm("r15");
+  SYSCALL_NA2(SYS_OPEN, path, flags);
+
+  if(ret != -1){
+    *fd = ret;
+    mlibc::infoLogger() << "[mlibc] Got sys_open return value " << *fd  << "\n" << frg::endlog;
+  }
+  else
+    return ENOENT; 
+
+  return 0;
+}
+
+int sys_open_dir(const char *path, int *handle){
+
+  mlibc::infoLogger() << "[mlibc] sys_open_dir; path: " << path << "\n" << frg::endlog;
+  return sys_open(path, O_DIRECTORY | O_RDONLY,  0, handle);
+}
+
+int sys_read_entries(int handle, void* buffer, size_t max_size, size_t* bytes_read)
+{
+    __ensure(max_size >= sizeof(dirent));
+
+    mlibc::infoLogger() << "[mlibc] sys_read_entries STUB; handle: " << handle << "\n" << frg::endlog;
+
+
+    *bytes_read = 0;
+    return 0;
+    register int ret asm ("r15");
+    SYSCALL_NA3(SYS_READDIR, handle, buffer, max_size);
+
+    dirent ret_entry;
+    DirectoryEntry  * entry  = (DirectoryEntry*)(buffer);
+
+    if(ret == -1){
+        *bytes_read = 0;
+        return 0;
+    }
+
+    ret_entry.d_ino =  entry->ino;
+    ret_entry.d_off = 0;
+    ret_entry.d_reclen = sizeof(DirectoryEntry);
+    memcpy(ret_entry.d_name, entry->name, 128);
+
+    mlibc::infoLogger() << "Got entry " << entry->name << "\n" << frg::endlog;
+    switch(entry->type){
+      case VFS_DIRECTORY:
+        ret_entry.d_type = DT_DIR;
+        mlibc::infoLogger() << "Type is DIR" << "\n" <<  frg::endlog;
+        break;
+      case VFS_FILE:
+        ret_entry.d_type = DT_REG;
+        mlibc::infoLogger() << "Type is FILE" << "\n" <<  frg::endlog;
+        break;
+      default:
+        ret_entry.d_type = DT_UNKNOWN;
+        mlibc::infoLogger() << "Type is UNKNOWN" << "\n" <<  frg::endlog;
+        break;
+    }
+
+    memcpy(buffer, &ret_entry, sizeof(dirent));
+    *bytes_read =  ret_entry.d_reclen;
+    //for(;;);
+
+    return 0;
+}
+
+int sys_close(int fd) {
+  mlibc::infoLogger() << "[mlibc] Close was called on " << fd << "\n" << frg::endlog;
+
+  return 0;
+}
+
+int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
+
+  mlibc::infoLogger() << "[mlibc] SYS_READ read called" << fd << " bytes";
+
+  register size_t ret asm("r15");
+  SYSCALL_NA3(SYS_READ, fd, buf, count);
+
+  if (ret >= 0) {
+    *bytes_read = ret;
+  } else {
+    return -1;
+  }
+
+  mlibc::infoLogger() << "[mlibc] SYS_READ read " << *bytes_read << " bytes"
+                      << frg::endlog;
+
+  return 0;
+}
+
+
+#ifndef MLIBC_BUILDING_RTDL
+int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) {
+
+  mlibc::infoLogger() << "[mlibc] Write was called on " << fd << "\n" << frg::endlog;
+  register size_t ret asm("r15");
+  SYSCALL_NA3(SYS_WRITE, fd, buf, count);
+
+  if (ret >= 0)
+    *bytes_written = ret;
+  else
+    return EBADF;
+
+  return 0;
+}
+#endif
+
+
+int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
+  // TODO
+
+    if(fd == 0 || fd == 1 || fd == 2)
+        return ESPIPE;
+  register off_t ret asm("r15");
+  SYSCALL_NA3(SYS_SEEK, fd, offset, whence);
+
+
+  if(ret == -1)
+    return EINVAL;
+
+  if(ret <0)
+      return EOVERFLOW;
+
+  *new_offset = ret;
+
+  mlibc::infoLogger() << "[mlibc] Sys seek got ret " << *new_offset << "\n" << frg::endlog;
+
+  return 0;
+}
+
+int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf){
+  mlibc::infoLogger() << "[mlibc] Calling sys_stat() STUB\n" << frg::endlog;
+
+
+  VfsNodeStat vns;
+  switch(fsfdt){
+    case fsfd_target::fd:{
+      mlibc::infoLogger() << "[mlibc] Calling fstat on " << fd << " fd\n" << frg::endlog;
+
+      register int ret asm ("r15");
+      SYSCALL_NA2(SYS_FSTAT, fd, &vns);
+
+      if(ret == -1)
+          return EBADF;
+      break;
+    }
+    case fsfd_target::path:{
+      mlibc::infoLogger() << "[mlibc] Calling stat on " << path << "\n" << frg::endlog;
+
+      register int ret asm("r15");
+      SYSCALL_NA2(SYS_STAT, path, &vns);
+      if(ret == -1){
+        mlibc::infoLogger() << "[mlibc] did not get statbuf for " <<path << "\n" << frg::endlog;
+        return ENOENT;
+      }
+      break;
+    }
+    default: {
+      mlibc::infoLogger() << "Invalid fsfd_target \n" << frg::endlog;
+
+      return EBADF; 
+      break;
+    }
+  }
+
+  memset(statbuf, 0, sizeof(struct stat));
+
+  statbuf->st_ino = (vns.inode % 15);
+  statbuf->st_size = vns.filesize;
+  statbuf->st_dev = 0;
+  statbuf->st_nlink = 1;
+  statbuf->st_uid = 0;
+  statbuf->st_gid = 0;
+  statbuf->st_rdev = 0;
+  statbuf->st_blksize = 0;
+  statbuf->st_blocks = 0;
+  statbuf->st_mode = 0;
+
+  switch (vns.type) {
+      case VFS_FILE:
+          mlibc::infoLogger() << "[mlibc] Regular file " << path << "\n" << frg::endlog;
+          statbuf->st_mode |= S_IFREG;
+          break;
+      case VFS_DIRECTORY:
+          mlibc::infoLogger() << "[mlibc] Regular directory " << path << "\n" << frg::endlog;
+          statbuf->st_mode |= S_IFDIR;
+          break;
+      case VFS_CHARDEVICE:
+          mlibc::infoLogger() << "[mlibc] Chardevice " << path << "\n" << frg::endlog;
+          statbuf->st_mode |= S_IFCHR;
+          statbuf->st_rdev = 0;
+          break;
+      default: sys_libc_panic();
+  }
+
+  mlibc::infoLogger() << "[mlibc] size: " << statbuf->st_size << " inode: " << statbuf->st_ino << "\n" << frg::endlog;
+
+  return 0;
+}
+
+
+int sys_access(const char* filename, int mode){
+    mlibc::infoLogger() << "[mlibc] Calling sys_access() STUB\n" << frg::endlog;
+    for(;;);
+    return ENOSYS;
+}
+
+int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd,
+               off_t offset, void **window) {
+  __ensure(flags & MAP_ANONYMOUS);
+
+  register uint64_t ret asm("r15");
+  SYSCALL_NA6(SYS_VM_MAP, hint, size, prot, flags, fd, offset);
+
+  mlibc::infoLogger() << "[mlibc] Derefing window at " << window << "\n" << frg::endlog;
+  *window = (void*)ret;
+  //mlibc::infoLogger() << "[mlibc] Got vm_map return value " << *window << frg::endlog;
+
+  return 0;
+}
+
+int sys_vm_unmap(void *pointer, size_t size) {
+  // TODO
+    return sys_anon_free(pointer, size);
+}
+
+int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
+
+    mlibc::infoLogger() << "[mlibc] Calling sys_futex_wait() STUB\n" << frg::endlog;
+
+  return 0;
+}
+
+int sys_isatty(int fd){
+  mlibc::infoLogger() << "[mlibc] Called sys_isatty on fd " << fd << "\n" << frg::endlog;
+  return 0;
+}
+
+int sys_ioctl(int fd, unsigned long request, void *arg, int *result) { 
+
+  mlibc::infoLogger() << "[mlibc] Called sys_ioctl() STUB; fd: " <<fd <<"\n" << frg::endlog;
+  //return ENOSYS;
+
+  switch(request){
+    case TIOCGWINSZ:{
+
+      mlibc::infoLogger() << "[mlibc] REQ: TIOCGWINSZ\n" << frg::endlog;
+      *result = 1920/8 * 1080/16;
+      return 0;
+      break;
+    }
+    case TIOCSWINSZ:{
+
+      mlibc::infoLogger() << "[mlibc] REQ: TIOCSWINSZ\n" << frg::endlog;
+      *result = 1920/8 * 1080/16;
+      return 0;
+      break;
+    }
+    case TIOCGPGRP:{
+      mlibc::infoLogger() << "[mlibc] REQ: TIOCGPGRP\n" << frg::endlog;
+
+      *result = 0;
+      return 0;
+      break;
+    }
+    case TIOCSPGRP:{
+      mlibc::infoLogger() << "[mlibc] REQ: TIOCSPGRP\n" << frg::endlog;
+      *result = 0;
+      break;
+    }
+    case TIOCSPTLCK:{
+      mlibc::infoLogger() << "[mlibc] REQ: TIOCSPTLCK\n" << frg::endlog;
+      *result = 0;
+      break;
+    }
+    case TIOCGPTN:{
+      mlibc::infoLogger() << "[mlibc] REQ: TIOCGPTN\n" << frg::endlog;
+      *result = 0;
+      break;
+    }
+    case TIOCSCTTY:{
+      mlibc::infoLogger() << "[mlibc] REQ: TIOCSCTTY\n" << frg::endlog;
+      *result = 0;
+      break;
+    }
+    case VT_RELDISP:{
+      mlibc::infoLogger() << "[mlibc] REQ: VT_RELDISP\n" << frg::endlog;
+      *result = 0;
+      break;
+    }
+    case VT_SETMODE:{
+      mlibc::infoLogger() << "[mlibc] REQ: VT_SETMODE\n" << frg::endlog;
+      *result = 0;
+      break;
+    }
+    case FBIOPUTCMAP:{
+      mlibc::infoLogger() << "[mlibc] REQ: FBIOPUTCMAP\n" << frg::endlog;
+      *result = 0;
+      break;
+    }
+    case FBIOGETCMAP:{
+      mlibc::infoLogger() << "[mlibc] REQ: FBIOGETCMAP\n" << frg::endlog;
+      *result = 0;
+      break;
+    }
+    case FBIOGET_FSCREENINFO:{
+      mlibc::infoLogger() << "[mlibc] REQ: FBIOGET_FSCREENINFO\n" << frg::endlog;
+
+      fb_var_screeninfo info;
+      info.xres = 1024;
+      info.yres = 720;
+      info.grayscale = 0;
+      info.bits_per_pixel = 32;
+
+      fb_var_screeninfo* buffer = (fb_var_screeninfo*)arg;
+      *buffer = info;
+
+      *result = 0;
+      break;
+    }
+    case FBIOGET_VSCREENINFO:{
+      mlibc::infoLogger() << "[mlibc] REQ: FBIOGET_VSCREENINFO\n" << frg::endlog;
+      *result = 0;
+      break;
+    }
+    default: {
+      for(;;)
+        mlibc::infoLogger() <<"[mlibc] Unsupported ioctl request \n" << frg::endlog;
+      *result = -1;
+      return ENOSYS;
+      break;
+    }
+  }
+
+  return 0;
+}
+
+int sys_futex_wake(int *pointer) {
+
+    mlibc::infoLogger() << "[mlibc] Calling sys_futex_wake() STUB\n" << frg::endlog;
+
+  return 0;
+}
+
+// All remaining functions are disabled in ldso.
+#ifndef MLIBC_BUILDING_RTDL
+
+int sys_clone(void *entry, void *user_arg, void *tcb, pid_t *tid_out) {
+  //void *sp = prepare_stack(entry, user_arg, tcb);
+  //int tid;
+
+  //asm volatile("syscall"
+  //             : "=a"(tid)
+  //             : "a"(67), "D"(__mlibc_start_thread), "S"(sp), "d"(tcb)
+  //             : "rcx", "r11");
+
+  //if (tid_out)
+  //  *tid_out = tid;
+
+
+    mlibc::infoLogger() << "[mlibc] Calling sys_clone() STUB\n" << frg::endlog;
+
+    return 0;
+}
+
+void sys_thread_exit() {
+
+    mlibc::infoLogger() << "[mlibc] Calling sys_thread_exit() STUB\n" << frg::endlog;
+
+  //asm volatile("syscall" : : "a"(68) : "rcx", "r11");
+  //__builtin_trap();
+}
+
+int sys_sleep(time_t *secs, long *nanos) {
+
+    mlibc::infoLogger() << "[mlibc] Calling sys_sleep() STUB\n" << frg::endlog;
+    return 0;
+}
+
+int sys_fork(pid_t *child) { 
+    mlibc::infoLogger() << "[mlibc] Calling sys_fork() STUB\n" << frg::endlog;
+    for(;;);
+    return 0; 
+}
+
+
+
+int sys_execve(const char *path, char *const argv[], char *const envp[]) {
+    mlibc::infoLogger() << "[mlibc] Calling sys_execve() STUB\n" << frg::endlog;
+    for(;;);
+    return 0;
+}
+
+
+uid_t sys_getuid(){
+    mlibc::infoLogger() << "[mlibc] Calling sys_getuid() STUB\n" << frg::endlog;
+    return 1000;
+}
+
+gid_t sys_getgid(){
+    mlibc::infoLogger() << "[mlibc] Calling sys_getgid() STUB\n" << frg::endlog;
+    return 1000;
+}
+
+uid_t sys_geteuid(){
+    mlibc::infoLogger() << "[mlibc] Calling sys_geteuid() STUB\n" << frg::endlog;
+    return 1000;
+}
+
+gid_t sys_getegid(){
+    mlibc::infoLogger() << "[mlibc] Calling sys_getegid() STUB\n" << frg::endlog;
+    return 1000;
+}
+
+
+pid_t sys_getpid() {
+
+    mlibc::infoLogger() << "[mlibc] Calling sys_getpid() \n" << frg::endlog;
+
+    register pid_t ret asm ("r15");
+    SYSCALL_NA0(SYS_GETPID)
+
+    pid_t res = ret;
+    mlibc::infoLogger() << "[mlibc] Got pid: " << res << frg::endlog;
+    return ret;
+}
+
+int sys_getpgid(pid_t pid, pid_t *pgid){
+    mlibc::infoLogger() << "[mlibc] Calling sys_getpgid() STUB\n" << frg::endlog;
+    *pgid = 0;
+   return 0;
+}
+
+
+int sys_setpgid(pid_t pid, pid_t pgid){
+    mlibc::infoLogger() << "[mlibc] Calling sys_setpgid() STUB\n" << frg::endlog;
+    return ENOSYS; 
+}
+
+pid_t sys_getppid() {
+    mlibc::infoLogger() << "[mlibc] Calling sys_getppid() STUB\n" << frg::endlog;
+    return ENOSYS;
+}
+
+int sys_dup(int fd, int flags, int * newfd){
+  mlibc::infoLogger() << "[mlibc] Calling sys_dup() \n" << frg::endlog;
+
+  register int ret asm("r15");
+  SYSCALL_NA2(SYS_DUP, fd, flags);
+
+  if(ret)
+    *newfd = ret;
+
+  mlibc::infoLogger() << "[mlibc] Calling sys_dup() \n" << frg::endlog;
+
+  return 0;  
+}
+
+int sys_dup2(int fd, int flags, int  newfd){
+
+  mlibc::infoLogger() << "[mlibc] Calling sys_dup2() \n" << frg::endlog;
+  register int ret asm("r15");
+  SYSCALL_NA3(SYS_DUP2, fd, flags, newfd);
+  if(ret != newfd)
+    return -1;
+  mlibc::infoLogger() << "[mlibc] sys_dup2(): success \n" << frg::endlog;
+
+  return 0;
+}
+
+
+int sys_waitpid(pid_t pid, int *status, int flags, pid_t *ret_pid){
+  mlibc::infoLogger() << "[mlibc] Calling sys_waitpid() STUB\n" << frg::endlog;
+  for(;;);
+  return 0;
+}
+
+
+int sys_getcwd(char* buffer, size_t size){
+    if(size < 2)
+        return EINVAL;
+    mlibc::infoLogger() <<"[mlibc]  getcwd called buffer size"  <<  size << frg::endlog;
+    buffer[0] = '/';
+    buffer[1] = '\0';
+    return 0;
+}
+
+int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {
+  mlibc::infoLogger() << "[mlibc] Calling sys_sigaction() STUB; Signal:" << signum << " \n" << frg::endlog;
+
+
+
+  switch(signum){
+    case SIGCHLD:{
+        mlibc::infoLogger() << "[mlibc] SIGCHLD"  << " \n" << frg::endlog;
+        *oldact = *act;
+        break;
+    }
+    case SIGUSR1:{
+        mlibc::infoLogger() << "[mlibc] SIGUSR1"  << " \n" << frg::endlog;
+        *oldact = *act;
+        break;
+    }
+    case SIGUSR2:{
+        mlibc::infoLogger() << "[mlibc] SIGUSR2"  << " \n" << frg::endlog;
+        *oldact = *act;
+        break;
+    }
+    default:
+        break;
+  }
+
+
+  return 0;
+}
+
+int sys_pipe(int *fds, int flags){
+    mlibc::infoLogger() << "[mlibc] Calling sys_pipe() STUB\n" << frg::endlog;
+    return 0;
+}
+
+int sys_fcntl(int fd, int request, va_list args, int* result_value){
+  
+  mlibc::infoLogger() << "[mlibc] Calling sys_fcntl() on " << fd << "\n" << frg::endlog;
+  switch(request){
+      case F_DUPFD:
+          mlibc::infoLogger() << "[mlibc] REQ: F_DUPFD " << "\n" << frg::endlog;
+          return sys_dup(fd, 0, result_value);
+          break;
+      case F_DUPFD_CLOEXEC:
+          mlibc::infoLogger() << "[mlibc] REQ: F_DUPFD_CLOEXEC " << "\n" << frg::endlog;
+          break;
+      case F_SETFD:
+          mlibc::infoLogger() << "[mlibc] REQ: F_SETFD " << fd <<  "\n" << frg::endlog;
+
+
+          if(fd<255){
+              mlibc::infoLogger() << "[mlibc] Calling sys_fcntl() on " << fd << "\n" << frg::endlog;
+              *result_value = 0;
+              return fd;
+          }else{
+              mlibc::infoLogger() << "[mlibc] Returning EBADF" << "\n" << frg::endlog;
+              return EBADF;
+          }
+          break;
+      case F_GETFD:
+          mlibc::infoLogger() << "[mlibc] REQ: F_GETFD " << "\n" << frg::endlog;
+          break;
+
+      case F_SETFL:
+          mlibc::infoLogger() << "[mlibc] REQ: F_SETFL " << "\n" << frg::endlog;
+          break;
+      case F_GETFL:
+          mlibc::infoLogger() << "[mlibc] REQ: F_GETFL " << "\n" << frg::endlog;
+          break;
+      default: sys_libc_panic();
+  }
+
+
+
+  return ENOSYS;
+
+}
+
+
+int sys_gethostname(char *buffer, size_t bufsize){
+  if(bufsize < 0)
+    return EINVAL;
+
+  for(size_t i=0; i<bufsize; i++)
+    buffer[i] = "root"[i];
+
+  return 0;
+}
+
+#endif // MLIBC_BUILDING_RTDL
+
+} // namespace mlibc
diff --git a/sysdeps/atlas/generic/thread.cpp b/sysdeps/atlas/generic/thread.cpp
new file mode 100644
index 00000000..35e7a9be
--- /dev/null
+++ b/sysdeps/atlas/generic/thread.cpp
@@ -0,0 +1,44 @@
+#include <mlibc/thread-entry.hpp>
+#include <mlibc/all-sysdeps.hpp>
+#include <mlibc/tcb.hpp>
+#include <bits/ensure.h>
+#include <sys/mman.h>
+#include <stdint.h>
+#include <stddef.h>
+
+extern "C" void __mlibc_enter_thread(void *entry, void *user_arg, Tcb *tcb) {
+	// Wait until our parent sets up the TID.
+	while(!__atomic_load_n(&tcb->tid, __ATOMIC_RELAXED))
+		mlibc::sys_futex_wait(&tcb->tid, 0, nullptr);
+
+	if(mlibc::sys_tcb_set(tcb))
+		__ensure(!"sys_tcb_set() failed");
+
+	void *(*func)(void *) = reinterpret_cast<void *(*)(void *)>(entry);
+	auto result = func(user_arg);
+
+	auto self = reinterpret_cast<Tcb *>(tcb);
+
+	self->returnValue = result;
+	__atomic_store_n(&self->didExit, 1, __ATOMIC_RELEASE);
+	mlibc::sys_futex_wake(&self->didExit);
+
+	mlibc::sys_thread_exit();
+}
+
+namespace mlibc {
+
+void *prepare_stack(void *entry, void *user_arg, void *tcb) {
+	uintptr_t *sp = reinterpret_cast<uintptr_t *>(reinterpret_cast<uintptr_t>(
+			mmap(nullptr, 0x200000,
+				PROT_READ | PROT_WRITE,
+				MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
+			) + 0x200000);
+
+	*--sp = reinterpret_cast<uintptr_t>(tcb);
+	*--sp = reinterpret_cast<uintptr_t>(user_arg);
+	*--sp = reinterpret_cast<uintptr_t>(entry);
+	return sp;
+}
+
+} //namespace mlibc
diff --git a/sysdeps/atlas/generic/thread_entry.S b/sysdeps/atlas/generic/thread_entry.S
new file mode 100644
index 00000000..ac321e6f
--- /dev/null
+++ b/sysdeps/atlas/generic/thread_entry.S
@@ -0,0 +1,9 @@
+
+.section .text
+.global __mlibc_start_thread
+__mlibc_start_thread:
+	pop %rdi
+	pop %rsi
+	pop %rdx
+	call __mlibc_enter_thread
+
diff --git a/sysdeps/atlas/include/abi-bits/access.h b/sysdeps/atlas/include/abi-bits/access.h
new file mode 120000
index 00000000..cb839316
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/access.h
@@ -0,0 +1 @@
+../../../../abis/linux/access.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/auxv.h b/sysdeps/atlas/include/abi-bits/auxv.h
new file mode 120000
index 00000000..c43f8786
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/auxv.h
@@ -0,0 +1 @@
+../../../../abis/linux/auxv.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/blkcnt_t.h b/sysdeps/atlas/include/abi-bits/blkcnt_t.h
new file mode 120000
index 00000000..0b0ec270
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/blkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blkcnt_t.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/blksize_t.h b/sysdeps/atlas/include/abi-bits/blksize_t.h
new file mode 120000
index 00000000..7dc8d7cf
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/blksize_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blksize_t.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/clockid_t.h b/sysdeps/atlas/include/abi-bits/clockid_t.h
new file mode 120000
index 00000000..6a42da56
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/clockid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/clockid_t.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/dev_t.h b/sysdeps/atlas/include/abi-bits/dev_t.h
new file mode 120000
index 00000000..bca881e9
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/dev_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/dev_t.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/epoll.h b/sysdeps/atlas/include/abi-bits/epoll.h
new file mode 120000
index 00000000..eb4b76dc
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/epoll.h
@@ -0,0 +1 @@
+../../../../abis/linux/epoll.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/errno.h b/sysdeps/atlas/include/abi-bits/errno.h
new file mode 120000
index 00000000..6e507def
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/errno.h
@@ -0,0 +1 @@
+../../../../abis/linux/errno.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/fcntl.h b/sysdeps/atlas/include/abi-bits/fcntl.h
new file mode 120000
index 00000000..463e2c95
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/fcntl.h
@@ -0,0 +1 @@
+../../../../abis/linux/fcntl.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/gid_t.h b/sysdeps/atlas/include/abi-bits/gid_t.h
new file mode 120000
index 00000000..6a772180
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/gid_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/gid_t.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/in.h b/sysdeps/atlas/include/abi-bits/in.h
new file mode 120000
index 00000000..418d1d5c
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/in.h
@@ -0,0 +1 @@
+../../../../abis/linux/in.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/ino_t.h b/sysdeps/atlas/include/abi-bits/ino_t.h
new file mode 120000
index 00000000..4c20aca2
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/ino_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/ino_t.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/inotify.h b/sysdeps/atlas/include/abi-bits/inotify.h
new file mode 120000
index 00000000..b5cb2823
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/inotify.h
@@ -0,0 +1 @@
+../../../../abis/linux/inotify.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/limits.h b/sysdeps/atlas/include/abi-bits/limits.h
new file mode 120000
index 00000000..6c88db2e
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/limits.h
@@ -0,0 +1 @@
+../../../../abis/linux/limits.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/mode_t.h b/sysdeps/atlas/include/abi-bits/mode_t.h
new file mode 120000
index 00000000..5d78fdfc
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/mode_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/mode_t.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/nlink_t.h b/sysdeps/atlas/include/abi-bits/nlink_t.h
new file mode 120000
index 00000000..bb3b625c
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/nlink_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/nlink_t.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/packet.h b/sysdeps/atlas/include/abi-bits/packet.h
new file mode 120000
index 00000000..998ef1ab
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/packet.h
@@ -0,0 +1 @@
+../../../../abis/linux/packet.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/pid_t.h b/sysdeps/atlas/include/abi-bits/pid_t.h
new file mode 120000
index 00000000..baa90f6a
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/pid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/pid_t.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/poll.h b/sysdeps/atlas/include/abi-bits/poll.h
new file mode 120000
index 00000000..8ea6a0a3
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/poll.h
@@ -0,0 +1 @@
+../../../../abis/linux/poll.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/ptrace.h b/sysdeps/atlas/include/abi-bits/ptrace.h
new file mode 120000
index 00000000..b2517b2c
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/ptrace.h
@@ -0,0 +1 @@
+../../../../abis/linux/ptrace.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/reboot.h b/sysdeps/atlas/include/abi-bits/reboot.h
new file mode 120000
index 00000000..77013a41
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/reboot.h
@@ -0,0 +1 @@
+../../../../abis/linux/reboot.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/resource.h b/sysdeps/atlas/include/abi-bits/resource.h
new file mode 120000
index 00000000..88d74025
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/resource.h
@@ -0,0 +1 @@
+../../../../abis/linux/resource.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/seek-whence.h b/sysdeps/atlas/include/abi-bits/seek-whence.h
new file mode 120000
index 00000000..df7bccf0
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/seek-whence.h
@@ -0,0 +1 @@
+../../../../abis/linux/seek-whence.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/shm.h b/sysdeps/atlas/include/abi-bits/shm.h
new file mode 120000
index 00000000..067d8c4f
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/shm.h
@@ -0,0 +1 @@
+../../../../abis/linux/shm.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/signal.h b/sysdeps/atlas/include/abi-bits/signal.h
new file mode 120000
index 00000000..4dcb0b7c
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/signal.h
@@ -0,0 +1 @@
+../../../../abis/linux/signal.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/socket.h b/sysdeps/atlas/include/abi-bits/socket.h
new file mode 120000
index 00000000..f1dc016e
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/socket.h
@@ -0,0 +1 @@
+../../../../abis/linux/socket.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/stat.h b/sysdeps/atlas/include/abi-bits/stat.h
new file mode 120000
index 00000000..1f63b41f
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/stat.h
@@ -0,0 +1 @@
+../../../../abis/linux/stat.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/termios.h b/sysdeps/atlas/include/abi-bits/termios.h
new file mode 120000
index 00000000..ee8f0b09
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/termios.h
@@ -0,0 +1 @@
+../../../../abis/linux/termios.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/time.h b/sysdeps/atlas/include/abi-bits/time.h
new file mode 120000
index 00000000..2a026257
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/time.h
@@ -0,0 +1 @@
+../../../../abis/linux/time.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/uid_t.h b/sysdeps/atlas/include/abi-bits/uid_t.h
new file mode 120000
index 00000000..b3067778
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/uid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/uid_t.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/utsname.h b/sysdeps/atlas/include/abi-bits/utsname.h
new file mode 120000
index 00000000..b2857547
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/utsname.h
@@ -0,0 +1 @@
+../../../../abis/linux/utsname.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/vm-flags.h b/sysdeps/atlas/include/abi-bits/vm-flags.h
new file mode 120000
index 00000000..bbe258cf
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/vm-flags.h
@@ -0,0 +1 @@
+../../../../abis/linux/vm-flags.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/vt.h b/sysdeps/atlas/include/abi-bits/vt.h
new file mode 120000
index 00000000..5798a4ac
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/vt.h
@@ -0,0 +1 @@
+../../../../abis/linux/vt.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/abi-bits/wait.h b/sysdeps/atlas/include/abi-bits/wait.h
new file mode 120000
index 00000000..feb2840c
--- /dev/null
+++ b/sysdeps/atlas/include/abi-bits/wait.h
@@ -0,0 +1 @@
+../../../../abis/linux/wait.h
\ No newline at end of file
diff --git a/sysdeps/atlas/include/mlibc/thread-entry.hpp b/sysdeps/atlas/include/mlibc/thread-entry.hpp
new file mode 100644
index 00000000..2dd88a64
--- /dev/null
+++ b/sysdeps/atlas/include/mlibc/thread-entry.hpp
@@ -0,0 +1,10 @@
+#pragma once
+
+#include <mlibc/tcb.hpp>
+
+extern "C" void __mlibc_start_thread(void);
+extern "C" void __mlibc_enter_thread(void *entry, void *user_arg, Tcb *tcb);
+
+namespace mlibc {
+	void *prepare_stack(void *entry, void *user_arg, void *tcb);
+}
diff --git a/sysdeps/atlas/include/vfs.h b/sysdeps/atlas/include/vfs.h
new file mode 100644
index 00000000..ba870bff
--- /dev/null
+++ b/sysdeps/atlas/include/vfs.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include <stdint.h>
+
+#define VFS_FILE            0x01
+#define VFS_DIRECTORY       0x02
+#define VFS_CHARDEVICE      0x03
+#define VFS_BLOCKDEVICE     0x04
+#define VFS_PIPE            0x05
+#define VFS_SYMLINK         0x06
+#define VFS_MOUNTPOINT      0x08
+#define VFS_INVALID_FS      0x09
+
+
+#define name_max            128
+
+typedef struct vfs_node_stat  {
+    uint32_t type;
+    uint64_t inode;
+    uint64_t filesize;
+} __attribute__((packed)) VfsNodeStat;
+
+typedef struct  {
+    char name[name_max];
+    uint32_t ino;
+    uint32_t type;
+} __attribute__((packed)) DirectoryEntry; 
+
diff --git a/sysdeps/atlas/meson.build b/sysdeps/atlas/meson.build
new file mode 100644
index 00000000..ec29b73b
--- /dev/null
+++ b/sysdeps/atlas/meson.build
@@ -0,0 +1,58 @@
+
+rtdl_sources += files(
+	'generic/generic.cpp'
+)
+
+libc_sources += files(
+	'generic/entry.cpp',
+	'generic/generic.cpp',
+	'generic/thread.cpp',
+	'generic/thread_entry.S'
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/auxv.h',
+		'include/abi-bits/seek-whence.h',
+		'include/abi-bits/vm-flags.h',
+		'include/abi-bits/errno.h',
+		'include/abi-bits/fcntl.h',
+		'include/abi-bits/in.h',
+		'include/abi-bits/resource.h',
+		'include/abi-bits/signal.h',
+		'include/abi-bits/stat.h',
+		'include/abi-bits/socket.h',
+		'include/abi-bits/termios.h',
+		'include/abi-bits/time.h',
+		'include/abi-bits/blkcnt_t.h',
+		'include/abi-bits/blksize_t.h',
+		'include/abi-bits/dev_t.h',
+		'include/abi-bits/gid_t.h',
+		'include/abi-bits/ino_t.h',
+		'include/abi-bits/mode_t.h',
+		'include/abi-bits/nlink_t.h',
+		'include/abi-bits/pid_t.h',
+		'include/abi-bits/uid_t.h',
+		'include/abi-bits/access.h',
+		'include/abi-bits/wait.h',
+		'include/abi-bits/limits.h',
+		'include/abi-bits/utsname.h',
+		'include/abi-bits/ptrace.h',
+		'include/abi-bits/poll.h',
+		'include/abi-bits/epoll.h',
+		'include/abi-bits/packet.h',
+		subdir: 'abi-bits'
+	)
+endif
+
+if not headers_only
+	crt = custom_target('crt0',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-x86_64/crt0.S',
+		output: 'crt0.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
+
-- 
2.37.1

